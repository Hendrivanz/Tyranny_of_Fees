<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>


<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Tyranny of Fees" />




<meta name="author" content="Hendri van Zyl" />

<meta name="date" content="2023-11-19" />

<meta name="description" content="Tyranny of Fees">

<script id="pandoc-meta" type="application/json">
{"author":"Hendri van Zyl","bibliography":"Tex/ref.bib","csl":"Template/harvard-stellenbosch-university.csl","date":"2023-11-19","newpage_html_class":"page-break-after","output":{"pagedown::html_paged":{"csl":"Template/harvard-stellenbosch-university.csl","css":["Template/default-fonts-Texevier.css","Template/default-page-Texevier.css","Template/default-Texevier.css"],"self_contained":true,"template":["Template/paged-Texevier.html"],"toc":false}},"title":"Tyranny of Fees"}
</script>

<title>Tyranny of Fees</title>


<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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AAIAFAAsAAEAAAAJAAEAAQD9AAMAAAABABwAAQASAAEAAAAJAAIAAQD3APwAAAABAAIAUwBZAAAB9ABdAAAAAAEYAAABGAAAAvwALgL8AC4C/AAuAvwALgL8AC4C/AAuAvwALgPsABoCsgA+Ap4ARgKeAEYDDAA+AwAAPgKyAD4CsgA+ArIAPgKyAD4CsgA+AqQAPgLQAEYDFAA+AYoAPgGKAD4BigAyAYoANgGKAD4CHAAsAvQAPgKeAD4CngA+A0YAPgMCAD4DAgA+ArwARgK8AEYCvABGArwARgK8AEYCvABGArwARgQYAEYCqAA+AqgAPgK8AEYCzAA+AmwAWALKAEgDDAA0AwwANAMMADQDDAA0AwwANAMEACwELAAmAu4ALgLYACoC2AAqAowARAHuAC4B7gAuAe4ALgHuAC4B7gAuAe4ALgHuAC4CvAAuAgAAFgG0ADABtAAwAgoAMAH0ADABzAAwAcwAMAHMADABzAAwAcwAMAFKABwCHAA0AiAAHAEOACYBDgAmAQ4AJgEaAAcBGgALAQ7/9AFA/9oBQP/aAggAHAEOABwBdAAcAxoAJgIcACYCHAAmAfAAMAHwADAB8AAwAfAAMAHwADAB8AAwAfAAMAL+ADACBgAcAfQAGgH2ADABmgAmAbIANAIOABwBXgAcAhYAIAIWACACFgAgAhYAIAIWACACEgASAwgAEgIIACICEgASAhIAEgISABIBuAAoAhIAHAISABwBfAA+AXwARgJEADACRAB4AkQASgJEAEgCRAA4AkQAVgJEAFACRABaAkQAPAJEAE4BfAAeAXwAVAF8ADQBfABEAXwALAF8ADYBfAA2AXwAPAF8ACgBfAAyAXwAHgF8AFQBfAA0AXwARAF8ACwBfAA2AXwANgF8ADwBfAAoAXwAMgF8AB4BfABUAXwANAF8AEQBfAAsAXwANgF8ADYBfAA8AXwAKAF8ADIAUv+AAzQAVAM0AFQDNABEAfYASAHCADgBGABOAfQAiAEYAE4BGABIA0gATgEYAE4BGABOAqwAUQEYAE4B1gBAAdYAIgGKAFYA8ABWARgASAHCADgCCAAAAaQAaAGkAFQBfAB4AXwARgFyAGIBcgAwA+gAPAJsADwBcgA8AXIAPAHgAGwB4AByAUoAbAFKAFsB0gBIAdIARgHSAEgBGABGARgASAEYAEgBGAAAAKQAAAAAAAACRABwAkQANAJEAD4CRAAiAtAAQAJEAA4CMAAwA6wAMAOsADADrACcA6wAMAOsADADrABQA6wAVAOsADAClAAwAkQAMAJeAD4DXABgAXgAMAF4ADADNAAwAxIANgIcAEACgABkAzQAMAM0ADAD1AAeAkQAmgEcAHgBHAB4AkQAPgEEACwBrAAsAAD+gAAA/vMAAP7zAAD+gAAA/pgAAP69AAD/NAAA/mgAAP7zAAD+8wAA/mQAAP6MAMgAKADIACgBcQBkAYIAZAHOAGQB5ABkAXEAZAHMAGQBjABkAeQAZAACAAAAAAAA/7UAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAQ0AAAECAAIAAwAkAMkAxwBiAK0AYwCuAJAAJQAmAGQAJwDpACgAZQDIAMoAywApACoAKwAsAMwAzQDOAM8ALQAuAC8BAwAwADEAZgAyANAA0QBnANMAkQCvALAAMwDtADQANQA2ADcAOADUANUAaADWADkAOgA7ADwA6wA9AEQAaQBrAGwAagBuAG0AoABFAEYAbwBHAOoASABwAHIAcwBxAEkASgBLAEwA1wB0AHYAdwB1AE0BBABOAE8BBQBQAFEAeABSAHkAewB8AHoAoQB9ALEAUwDuAFQAVQBWAIkAVwBYAH4AgACBAH8AWQBaAFsAXADsALoAXQDAAMEAnQCeABMAFAAVABYAFwAYABkAGgAbABwBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMAvAD0APUA9gANAD8AwwCHAB0ADwCrAAQAowAGABEAIgCiAAUACgAeABIAQgBeAGAAPgBAAAsADACzALIAEAEkAKkAqgC+AL8AxQC0ALUAtgC3AMQBJQEmAScAhAC9AAcBKACFAJYBKQAOAO8A8AC4ACAAIQAfAJMAYQCkASoACAErASwAIwAJAIgAhgCLAIoAjACDAF8A6ABBAS0BLgEvATABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwAjQDeANgAjgBDANoA3QDZBE5VTEwETGRvdAd1bmkwMjM3BGxkb3QJemVyby5kbm9tCG9uZS5kbm9tCHR3by5kbm9tCnRocmVlLmRub20JZm91ci5kbm9tCWZpdmUuZG5vbQhzaXguZG5vbQpzZXZlbi5kbm9tCmVpZ2h0LmRub20JbmluZS5kbm9tCXplcm8ubnVtcghvbmUubnVtcgh0d28ubnVtcgp0aHJlZS5udW1yCWZvdXIubnVtcglmaXZlLm51bXIIc2l4Lm51bXIKc2V2ZW4ubnVtcgplaWdodC5udW1yCW5pbmUubnVtcgd1bmkyMDcwB3VuaTAwQjkHdW5pMDBCMgd1bmkwMEIzB3VuaTIwNzQHdW5pMjA3NQd1bmkyMDc2B3VuaTIwNzcHdW5pMjA3OAd1bmkyMDc5B3VuaTAwQUQHdW5pMDBBMAd1bmkyMDA5B3VuaTIwMEIERXVybwd1bmkyMjE1B3VuaTAwQjUHYXJyb3d1cAlhcnJvd2Rvd24GbWludXRlBnNlY29uZAd1bmkwMzA4CWdyYXZlY29tYglhY3V0ZWNvbWIJdGlsZGVjb21iB3VuaTAzMDQNaG9va2Fib3ZlY29tYgxkb3RiZWxvd2NvbWIMdW5pMDMwOC5jYXNlDmdyYXZlY29tYi5jYXNlDmFjdXRlY29tYi5jYXNlDnRpbGRlY29tYi5jYXNlDHVuaTAzMDQuY2FzZQd1bmkwMkJDB3VuaTAyQkIAAQAAAAoATgCaAANERkxUADRjeXJsACRsYXRuABQABAAAAAD//wADAAIABQAIAAQAAAAA//8AAwABAAQABwAEAAAAAP//AAMAAAADAAYACWtlcm4ARmtlcm4ARmtlcm4ARm1hcmsAQG1hcmsAQG1hcmsAQG1rbWsAOG1rbWsAOG1rbWsAOAAAAAIAAgADAAAAAQABAAAAAQAAAAQCPgDUAKoACgAGAgAAAQAIAAEAiACIAAEAWgAMAAsASABCAEIAPAA2ADAAKgAkACQAHgAYAAH/FANeAAH/AAOKAAH/SAOqAAH/AgOGAAH/EgKOAAH/GgJkAAH/DgKMAAH/SAKsAAH/DgKEAAsAAAHCAAABvAAAAbwAAAHCAAABtgAAAbAAAAGkAAABngAAAZgAAAGYAAABkgACAAIA9wD8AAAA/gECAAYABgEAAAEACAABABwAHAABABYADAABAAQAAf9o/z4AAQAAAU4AAQABAP0ABAAAAAEACAABAVgA0gACAPAADAANAMAAugC0AK4AqACiAJwAlgCQAIoAhAB+AHgAcgBsAGYAYABaAGAAVABOAEgAQgA8AIQANgABAQkByAAB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) format('truetype');
}
body {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;
}
blockquote {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '楷体', 'SimKai', 'DFKai-SB', 'NSimSun', serif;
}
code {
font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;
}
pre, code {
font-size: .95em;
}</style>
<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
background-image: var(--front-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.front-cover {
break-after: recto;
}

.front-page {
counter-reset: page 1;
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:left {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.back-cover {
break-before: verso;
}
.pagedjs_page:nth-last-of-type(1) {
background-image: var(--back-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.level1 {
break-before: avoid;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-before: avoid;
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page 1;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}
.abstract {
border-width: 0.5px 0;
border-style: solid;
margin-top: 0px;
margin-bottom: 2px;
font-size: 12px;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

h1 {
font-weight: bold;
font-size: 23px;
}
h2 {
font-weight: bold;
font-size: 20px;
}
p {
font-size: 12px;
}
.sourceCode {
font-size: 10px;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: hidden;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
font-size: 11px;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Tyranny of Fees</h1>
<h5 class="author">Hendri van Zyl</h5>
<h5 class="date">2023-11-19</h5>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<div class="page-break-after"></div>
<div id="introduction" class="section level2 unnumbered">
<h2>Introduction</h2>
<p>This document seeks to illustrate the effect of different management fee scales on cumulative returns of clients.</p>
<p>We are using the Jalshtr total return index data that is accessible via the fmxdat package to measure the impact of various levels of fees on cumulative returns over time.</p>
</div>
<div id="from-inception" class="section level2 unnumbered">
<h2>From inception</h2>
<p>First we compare the impact of the fee levels from the earliest available data point in 2002.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAPACAYAAAD0ZtPZAAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAVAoAMABAAAAAEAAAPAAAAAALYRw1EAAEAASURBVHgB7J0H3BU11odDlyYIil0QFcVeURE7dkXFXrGthVVXXcXee8OOBXuvWD/rqiAqtrXj2lDsIogNFEHwu89IrrlzM7fO3Pb+z+/3vjN3JpNJnplkkpOTk2Z/psRIREAEREAEREAEREAEREAEREAEREAEREAEREAERKABCTRvwDwpSyIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQEJACVC+CCIiACIiACIiACIiACIiACIiACIiACIiACIhAwxKQArRhH60yJgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAWo3gEREAEREAEREAEREAEREAEREAEREAEREAEREIGGJSAFaMM+WmVMBERABERABERABERABERABERABERABERABERAClC9AyIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAg1LQArQhn20ypgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAUoHoHREAEREAEREAEREAEREAEREAEREAEREAEREAEGpaAFKAN+2iVMREQAREQAREQAREQAREQAREQAREQAREQAREQASlA9Q6IgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAg0LAEpQBv20SpjIiACIiACIiACIiACIiACIiACIiACIiACIiACUoDqHRABERABERABERABERABERABERABERABERABEWhYAlKANuyjVcZEQAREQAREQAREQAREQAREQAREQAREQAREQASkANU7IAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIi0LAEpABt2EerjImACIiACIiACIiACIiACIiACIiACIiACIiACEgBqndABERABERABERABERABERABERABERABERABESgYQlIAdqwj1YZEwEREAEREAEREAEREAEREAEREAEREAEREAERaCkEIiACIiACTY/An3/+aT788EMzYcIEM3nyZNOmTRsz99xzB3+LLLKIadGiRdODohyLgAiIgAiIgAiIgAiIgAiIgAg0JAEpQBvgsX7++edmzz33jCUn88wzj7nnnntiiasWIzn33HPN/fffn5E0FD0vvPBCxjH9EIFGJfDOO++Ya665xowcOTJQfPryOddcc5n+/fubzTff3Gy88ca+IDoWE4FbbrnFXHHFFRmx9enTx1x66aUZx/TjbwKHHnqoefvtt/8+kNobNGiQ2XvvvTOO5fvxzDPPmOOOOy4r2IABA7zHbcA77rjDXHLJJfZnervRRhuZ008/Pf07vPPtt9+abbbZJnzY7LjjjuaII47IOl7LB5J8b2+44QYzYsSIjOyvt9565t///nfGMf0QAREQAREQAREQAREQgWIISAFaDK0aDTt9+nTz0UcfxZK6X375JZZ4ajWSH374wXzxxRcZyZOlWwaOmvuBwm7atGkZ6VpiiSVM586dM47pR24CvPvHHnusefjhh3MHTJ0lLAMh/K2xxhrmnHPOMTCXxE/g559/zqqTevToEf+NImKsx/JFHR7+5n3//fcROYw+vOKKK5ovv/zSYA3tyn/+85+cCtCXXnop65lx/ahRo9xosvZfffVV73XLLrtsVthaP1DMe1vsO/bVV1+Z119/PQNBJctExo31QwREQAREQAREQAREoGEISAHaMI9SGRGBxiTwz3/+04wbNy4jczfddFNgoZhxUD8iCaAswkLus88+iwwTdQJlD5Zt1113ndlwww2jgul4nRJoyuWrS5cuZqWVVspStuEa4qeffjKdOnXyPlUUej6hnkIxOOecc/pOGxSgYWnVqpVZa621wocb6ndTfsca6kEqMyIgAiIgAiIgAiJQ5wS0CFKdP0AlXwREQARyEZg4caLZaaedSlJ+2nhnzJhh9t9/f68Cx4bRVgTqkQBTq8OCReh///vf8OHg92+//ZZlfeoGDE/Nd8/5FKC4O2jfvr0bTPsiIAIiIAIiIAIiIAIiIAIJEJAFaAJQayVKrFCK7VjhA1QiAiLQGAT++OMPc8ABBwQLHflyNMccc5gVVljBrLrqqoZ9LEXfffdd88knn2QFxw3BP/7xDzNmzBjTtm3brPM6IAL1SGCDDTYwQ4cOzUo6ykrOheV///ufmTVrVvhw+vebb75p+vXrl/5td3799VczduxY+zO99Slg0ye1IwIiIAIiIAIiIAIiIAIiEBsBKUBjQ1l7EQ0ZMqToRSFqLxdKkQiIQKkEbr31VvPyyy97L2c6+1VXXWXatWuXcR7rN6a7n3322Vm+V7EmHT58uGERGokINAIBBgBY9Au/t674rDU5HzX93V6LAtQnb7zxhpk5c2bWqfXXXz/rmA6IgAiIgAiIgAiIgAiIgAjET0AK0PiZNokYJ0+ebN577z3DqrZYjS6wwAJlL5KSRJxJPwwUQvhVxDpuoYUWCv5atvQXKyyAPv30U8NiHd27dw/+4kgfPuew2GMxrGWWWaZoq99wGngO+LJj261bNzPffPMF21IXi0KhxqIl+NXr0KGDWXjhhYM4S40vnN64f8Px448/Nu+//37wfi+22GKmd+/eQbqbNWsW2+3gO378eMM7tOCCC5pFF1207GfnJg5lCwpOn+y8887mvPPOM75nQB73228/w8Is2223Xdblw4YNCyxBa8kKtBbKYRaoCh2Iu7yWkmzSEPf3gHoSZSP16uKLL15Ksgq6pnnz5mbdddc1DzzwQEZ4FJa4fsBHpythBWjPnj0zLKbfeustN3h636dQpW6lbilEkmBcC+9OIXn3haF+o46mDmWBNuppX33mu1bHREAEREAEREAEREAEmiYBv6amabJQrvMQ+Oabb8xpp50WWJRNmDAhKzQd1QEDBpiDDz44cvGI8EVJxBm+R6m/TznlFDNy5MiMy48++miz2WabBcdRIIU7u/PPP7856KCDzL777pu+7vPPPzfnnnuuefzxxzMs6nBRsMMOO5gTTjjBtG7dOh3e3TnssMMMi9C4csUVV5hVVlkl8FHH6twvvvhi+jTKKzrkG2+8sTnyyCODac3pkzl2RowYYVhYCMVn2BKKy1gMZMsttzQDBw4MVgXPEVVwCqXnDTfcYB588MGgkzplypSMS+io9u3b1wwePNiss846Gef4wbXPPfdccJx3JCyXXHKJue2224LDW221VZCucJhif19//fUGi0kYMHU8LLiTQFnB81pttdXCpzN+X3311eaOO+7IOMb08d122y1Q6lxwwQWGlabDwqrUxx13XCyLojz22GPeFadR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l3G5+8ywoP1L24fng/sf+gPFSDXKCOmjHrUrvtPOQflei8IAMq556GvwDtEegzGK5kL6WzZPccVj49NWBERABKpNQArQaj8B3V8EREAEREAEREAEREAEREAERKCmCdx///3phSnx5V+uBWhNZ1aJEwEREIEGJKAp8A34UJUlERABERABERABERABERABERCB+Ajce++9QWTMTrGWoPHFrphEQAREQASSJiAFaNKEFb8IiIAIiIAIiIAIiIAIiIAIiEDdEmDRUBYxRbbffnu5k6rbJ6mEi4AINGUCmUtwNmUSyrsIiIAIiIAIiIAIiIAIiIAIiIAIpAiwWBf+yPG/+uabbwZMWH+AxdwkIiACIiAC9UdACtD6e2ZKsQiIgAiIgAiIgAiIgAiIgAiIQIIEJk6caEaOHJm+Q4sWLcyRRx5p5pprrvQx7YiACIiACNQPASlA6+dZKaUiIAIiIAIiIAIiIAIiIAIiIAIVINCrVy/DivNt27Y1PXv2NAMGDDArrLBCBe6sW4iACIiACCRBQKvAJ0FVcYqACIiACIiACIiACIiACIiACIiACIiACIiACNQEAS2CVBOPQYkQAREQAREQAREQAREQAREQAREQAREQAREQARFIgoAUoElQVZwiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI1QUAK0Jp4DEqECIiACIiACIiACIiACIiACIiACIiACIiACIhAEgSkAE2CquIUAREQAREQAREQAREQAREQAREQAREQAREQARGoCQJSgNbEY1AiREAEREAEREAEREAEREAEREAEREAEREAEREAEkiAgBWgSVBWnCIiACIiACIiACIiACIiACIiACIiACIiACIhATRCQArQmHoMSIQIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIikAQBKUCToKo4RUAEREAEREAEREAEREAEREAEREAEREAEREAEaoKAFKA18RiUCBEQAREQAREQAREQAREQAREQAREQAREQAREQgSQISAGaBFXFKQIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiUBMEpACticegRIiACIiACIiACIiACIiACIiACIiACIiACIiACCRBQArQJKgqThEQAREQAREQAREQAREQAREQAREQAREQAREQgZogIAVoTTwGJUIEREAEREAEREAEREAEREAEREAEREAEREAERCAJAlKAJkFVcYqACIiACIiACIiACIiACIiACIiACIiACIiACNQEASlAa+IxKBEiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAJJEJACNAmqilMEREAEREAEREAEREAEREAEREAEREAEREAERKAmCEgBWhOPQYkQAREQAREQAREQAREQAREQAREQAREQAREQARFIgoAUoElQVZwiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI1QaBlTaRCiSiawLvvvmuef/754Lq1117bLLPMMkXHMXPmTPPnn38G17Vo0cI0a9as6Djq4QLySF6R5s2bB3/1kO5S0tgUnynvLe9vo4qeaeM9WT3Txnums1LfmFlN7Huqurcx3mO3jdToz3TWrFmGP6SptHsb/Znqe9oY9ZCbC5VTl0Zj7DeVNhJP648//ggeWqPXvfVcTqUArdN65dlnnzWHHnpokPrLL7+8JAXo1KlTzYzp04M4Os81V8MqkaiIfv7ppyCfbdq0MR06dqzTp54/2VN++SVd8c7VpUvDKrWpdH/68ccASKtWrcycnTrlh1OnIX5NldPps8tpp86dTcuWjVlt04mxz7R1qpx2bOByOnXKFDNjxozgjWzkuvdPp5y2TJXTTg1cTqf++quZ/vvvwTOlPqJeakTJKKetW5uOc87ZiNkM8tRU2kgoQG3dy/eF70yjCt/T35tAOVUbqTHfYFtOUd7TdmhU+S31PZ02bVqQPb4xrVPfmkaUptpGoi1Im7ARxf2eNnw5/e03My31h9Bno+9WL6Ip8PXypJROERABERABERABERABERABERABERABERABERCBoglIAVo0Ml0gAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiJQLwSkAK2XJ6V0ioAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIFE1ACtCikekCERABERABERABERABERABERABERABERABERCBeiEgBWi9PCmlUwREQAREQAREQAREQAREQAREQAREQAREQAREoGgCUoAWjUwXiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI1AsBKUDr5UkpnSIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAkUTkAK0aGS6QAREQAREQAREQAREQAREQAREQAREQAREQAREoF4ISAFaL09K6RQBERABERABERABERABERABERABERABERABESiagBSgRSPTBSIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAvVCQArQenlSSqcIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEDRBKQALRqZLhABERABERABERABERABERABERABERABERABEagXAlKA1suTUjpFQAREQAREQAREQAREQAREQAREQAREQAREQASKJiAFaNHIdIEIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEC9EJACtF6elNIpAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiJQNAEpQItGpgtEQAREQAREQAREQAREQAREQAREQAREQAREQATqhYAUoPXypJROERABERABERABERABERABERABERABERABERCBoglIAVo0Ml0gAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiJQLwSkAK2XJ6V0ioAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIFE1ACtCikekCERABERABERABERABERABERABERABERABEYiPwKcTPokvMsWURUAK0CwkOiACIiACIiACIiACIiACIiACIiACIiACIiAClSEw/IkrzdpHr2YefHlEZW7YBO/SsgnmWVkWAREQAREQAREQAREQAREQAREQAREQAREQgaoTuOE/w82Jtx4TpGPwsP3MzJl/mIF9d6x6uhotAbIAbbQnqvyIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAjUPIFbn73RHHfzUel0zpw10xx81QHm7tG3p49pJx4CDWkB+scff5gzzjjDtGrVyhx//PF5Sc2cOdN88MEH5q233gr+pkyZYhZffHHTq1cvs9FGGwXx5I0kFGDGjBnm8ccfDx3N/rnQQguZlVZaKfuEjoiACIiACIiACIiACIiACIiACIiACIiACDQkgbtG32aOuuEw8+eff2bkb9afs8y/hg82M2bOMLutNyjjXKP/mDppkpny3XdmniWXNM1btIg1uw2pAB09erQZPny46dixY14F6G+//Wb22Wcf89xzz3nBLrvssuaSSy4xSy21lPd81MHx48ebAw88MOp0+vi2225rLr/88vRv7YiACIiACIiACIiACIiACIiACIiACIiACDQuAXx9Hj784Czlp80xStEjr/9XoATda8P97OHEt2OGDTMP/PMQs/u9d5vlttuupPv98fvvZtQFF5j3/+9RM/H9903Ltm1Nt969TZ999zEr7rKLN84pEyeaW3fY0Xw66i/dXOuOHcyWF15gVv/HP7zhSznYcArQadOmmaFDhxbEYurUqWbQoEFmzJgxQXgsMVdZZRXToUMH89///tegSH333XfNNttsEyhIu3XrVlC8BPr000+DsC1btjTt27ePvK5du3aR53RCBERABERABERABERABERABERABERABESgcQiM+/Zjc9g1gw2WnrkEJegxN/7b9Jx3MbPOsuvnChrLuc9SurH/G3J0EFfYKrXQG0z9/nszbK1+ZtIHHwaXdFp4ITMjZXg47ulngr+37r7H7HHfvaZ580yPnLdst70ZP/p503vAVmax9dczo4deZEbsf6DpOO+8ZukBAwq9fc5wDaEA/fHHH824cePM66+/bu68807zfkrDXIhcddVVaeXnKaecYv4R0iw/8MAD5p///Kf55ZdfzOmnn24uu+yyQqINwmABimDhefHFFwf7+icCIiACIiACIiACIiACIiACIiACIiACItA0CaD0RPn52/TfCgKwQ79dTL9l1i0obDmB3nvoIXPXnoPMjKm/lhONGXHAgYHyc65Fe5g97r3HLLjyykF8Y1P6tTt2292898CD5rmUdeh6Q4ak74PiFeXnkpttavZ68IHg+NJbbWXO77WkeerU02JTgGaqXNO3r6+dPn36mAEpjTBKzEKVn+TwvvvuCzKKn8+w8pMTWH5uuummQZhHH33UzJqVWzsfBJz9z1qALrbYYu5h7YuACIiACIiACIiACIiACIiACIiACIiACDRBAtc8foV59aOXC8r5tmtsby7Zf5hp3iw51R1Tz2/fZVdz09bbmmk//VxQuqIC/Z4yHnx3xIjg9PbXDk8rPzmwTEq/1v+kE4Nzrwy/Ntjaf1+mZmAjPdddxx4yXVO6tDkXXNBMSM3KLkYXl47As5McRc/NkjqEn87ll18+/de1a9e8t2L6+2effRaEW2211SLDo1xFmFpvlZqRgZ0TNiyLKUlEQAREQAREQAREQAREQAREQAREQAREQASaLoFx33xkzrn3jIIADFg9tV7MQdckqvyc8L//mQuXXsa8deddpkWb1marSy4ynbsvUlD6fIEmphYXN7PXc+ret29WkEXX+UvB+X1qBjfT4q1M/W5isNu2Sxd7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sssMPkS3vuzSLEZuuHz7TV4BihXO2Wefba6++uqA1VypEbXDDz/c7LnnnolacLAIEyMgWBi89957+Z6TzouACIiACIiACIiACIiACIiACIiACIiACNQRgXfGv+VN7UbN5g2Un5xcvseKf019D4VsPs88ptXqa4aO5v85deJE8/JVf+m4wqFZfT0pBegr110f3G7NwYMzlJ82DSvvvntgBfrRU/8xY1I+Pne47lp7KnL7W2r23Kjzzjfzp6a+L1em4rbJK0Dx7WlXet9yyy0Dq8+uXbtGwo/zRPvU1HUUoI081TNOXopLBERABERABERABERABERABERABERABOqBwFfff2mm/j41K6k9TQezZrN5guNMfV9mkeWywjSfp5tptfGmJmWZl3Uu34F2c89tVt17L2+whVMLDiUl33/8cRD1Iqv3ibxF99SUeBSgE99/PzKMe2L0hUPNbz/8aHa86cayrD+Js0krQK+77rq08hM/n3vttZfLuaT931K+EPbYY49g0Z399tvPbLbZZt548Iv2zTffBOeWWGIJbxgdFAEREAEREAEREAEREAEREAEREAEREAERqD8CH339QVaiWfRoYPOFjF1saKmFemcp9pqVofzkhl169DA7XH9d1r2TPtA+pXid9uNP5ufZui7f/Wb89pef37YF+DOeOmmSGX3xxWbhlEI17DPUF3e+Y395N80XqkHP33LLLUHO9t1331iUn0TWNmVO/GPKT8NLL71kbr755khy11xzTXCOVbXWWmutyHA6IQIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiUF8EPvQoQLdsNr/pbP5e4KtT+8wFfZt3m7dky89q01lgts/PDx59zJsUFgD78IkngnM2rDfg7IMjzz3PTP9litnkjNNzBSv4XJNVgE6ePNl89NFHAai+ffuaN954I++fXTmSi8aOHRssYsRCRjfccEMG8E03TZkpp+S5554LVpBnRTBXbr/9dnPllVcGh3bZZRcjC1CXjvZFQAREQAREQAREQAREQAREQAREQAREoL4JfPhVpgXoUqajWblZl4xMdWrXOf27Wdt2puWGG5lmJUx7T0dSgZ1377rbPJ9STr422+enveXahx9mmqVWkWeK+yNHHmUPB9uZqfV3/i917Js33zJt5uxo+uy3b8b58I+fv/7avHjFFabneuuaJfr3D58u6XeTnQL/6quvpoFhAVqIvPjii6Z79+5B0GnTppmPZ/s3QJnqymGHHWZeeeUV88ILL5hhw4aZu+++O1jlHetQFjz65JNPguBLLbWUGTJkiHup9kVABERABERABERABERABERABERABERABOqcwEeOAjS11rvZOjX13ZX2bdqbli3+Vsu1XCu1EnybNm6Qmtx/7957zfiRo8xCffqYvoMPSqex+5prmv4nn2SeOukUg+/Od++7zyy2/vqmecuW5pNRo8ykDz8KFKQDr7rSzDVbt5a+OLTz9JlnmT9S0+Xjsv4k+r9Jh27W6D9ffvnlxLLYMvVw8S966aWXBtahk1J+C55++umM++2zzz7mhBNOMG3q4OXOSLh+iIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI5CTgToEf0GzBlP1n5oJG7vT3Fr2WNM0XWjhnfPVwsv+JJ5pFVl/dPHjov8ykDz40r91wYzrZi6y5htl22BVmgRVXTB/z7UweP968Mny46bXpJqZHjC4jG1IBeuqppxr+cslJJ51k+CtVVlllFfPVV19FXs7K7scff7wZPHiweeedd8ynn35qOnToEEx3X3zxxU27du0ir9UJERABERABERABERABERABERABERABERCB+iQw6eeJ5ocpf80WXtZ0Mss2+3uqu82Rnf7eLKUrarHa6vZwVbfHfPrXjOVcidjxnruD0+i9fNJr443NUe//z/yami09ITULumXK8K9bagZ0m4jw4Tg+S82+XnbgQLP+MUeHT5X1uyEVoGURifniuVIrW62zzjrBX8xRKzoREAEREAEREAEREAEREAEREAEREAEREIEaI+Baf27YfF5v6jq1TylFmzUzLfutU/N+P70ZyHOwXZcuZtF+/fKEyj690q67Gv7ilia7CFLcIBWfCIiACIiACIiACIiACIiACIiACIiACIiACFj/n21Tvj/nMXN4gTAFvsXSy5jm883vPa+D8RKQAjRenopNBERABERABERABERABERABERABERABESgCROwK8B3i1B+gqbTvAubliuv2oQpVTbrUoBWlrfuJgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIi0MAEPvrmwyB38zTzW3/O0WoO065Xb2NatGhgCrWVNSlAa+t5KDUiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAJ1TOCjrz8IUt/NtPbmAv+fzTplL4zkDayDsRCQAjQWjIpEBERABERABERABERABERABERABERABESgqROY8tsv5pvJXwcYukVYgOL/s3lq0WxJ5QhIAVo51rqTCIiACIiACIiACIiACIiACIiACIiACIhAAxNwV4Cf17Tx5lQWoF4siR6UAjRRvIpcBERABERABERABERABERABERABERABESgqRCw09/nSK0A3zFiCnz7rvPJ/2eFXwgpQCsMXLcTAREQAREQAREQAREQAREQAREQAREQARFoTAIffvXXAkjdmvmtP8l15wV7NGbmazhXUoDW8MNR0kRABERABERABERABERABERABERABERABOqHwIdfvR8ktpvxrwDfqkUr03n+7vWToQZJqRSgDfIglQ0REAEREAEREAEREAEREAEREAEREAEREIHqErBT4OeJ9P+pBZCq8YSkAK0Gdd1TBERABERABERABERABERABERABERABESgoQj8PuN38/nEz4I8RVmAdmrX2TTr3Lmh8l0PmZECtB6ektIoAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiJQ0wQ+/W6cmfXnrCCNkQrQDinl55ydajofjZg4KUAb8akqTyIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAhUl8PG3Hwf3a51aAb5Ts1bee7fv0s00a+U/571AB2MhIAVoLBgViQiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQFMm8OmEcUH2u5nWkRi0AFIkmkRPSAGaKF5FLgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIi0BQIfPztR0E2o6a/t2jewnRdeLGmgKKkPE6dNMlMeO89M2vmzJKuz3VRy1wndU4EREAEREAEREAEREAEREAEREAEREAEREAERCA/gXFWAdqsjTfwnO1YAb6L91w1Dv7x++9m1AUXmPf/71Ez8f33Tcu2bU233r1Nn333MSvusktJSSolzikTJ5pbd9jRfDrquf9n7zwA4yivtX1md7XSFvXem3s37oUabDqh5oeEBAgXEkoSSCOkAUkuNSGUSyd0EkI11WBjbGPABdxtucuy1Ww1q3dp/3NmNastM9JKlovk9yTSzHxtvnl2tcivTlHvaQ130vn/+DvNuP76fu1BbxIEUD0qaAMBEAABEAABEAABEAABEAABEAABEAABEACBIAm0d7TTvvICdXQ8henOinJEHjcV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AQQQQAABBBBAAIECChAALSA2b1UaAkP6D7Ez/nCMDTmqxqb2f8O+rJpsC+wrq69b4CYxWmbmgp76qa+vsU8GPme//OMh1q2za/lJQgABBBBAAAEEEEAAAQQQQAABBBCInABd4CNXJBxQVATGj5tg48etOpolS5bY9M+m2cxp39iymlobsfFaduCaR63agEcIIIAAAggggAACCCCAAAIIIIAAApETIAAauSLhgKIq0KFDBxu23tr+J6rHyHEhgAACCCCAAAIIIIAAAggggAACCKQK0AU+1YNnCCCAAAIIIIAAAggggAACCCCAAAIIIBAjAQKgMSpMsoIAAggggAACCCCAAAIIIIAAAggggAACqQIEQFM9eIYAAggggAACCCCAAAIIIIAAAggggAACMRIgABqjwiQrCCCAAAIIIIAAAggggAACCCCAAAIIIJAqQAA01YNnCCCAAAIIIIAAAggggAACCCCAAAIIIBAjAQKgMSpMsoIAAggggAACCCCAAAIIIIAAAggggAACqQIEQFM9eIYAAggggAACCCCAAAIIIIAAAggggAACMRIgABqjwiQrCCCAAAIIIIAAAggggAACCCCAAAIIIJAqQAA01YNnCCCAAAIIIIAAAggggAACCCCAAAIIIBAjAQKgMSpMsoIAAggggAACCCCAAAIIIIAAAggggAACqQIEQFM9eIYAAggggAACCCCAAAIIIIAAAggggAACMRIgABqjwiQrCCCAAAIIIIAAAggggAACCCCAAAIIIJAqQAA01YNnCCCAAAIIIIAAAggggAACCCCAAAIIIBAjAQKgMSpMsoIAAggggAACCCCAAAIIIIAAAggggAACqQIEQFM9eIYAAggggAACCCCAAAIIIIAAAggggAACMRIgABqjwiQrCCCAAAIIIIAAAggggAACCCCAAAIIIJAqQAA01YNnCCCAAAIIIIAAAggggAACCCCAAAIIIBAjgYoY5WW1zcqkSZNsyZIleed/6dKlVldX5/fr0KGDtWsXz3i48qi8KlWUl1tVdbV/HMf/dB7U19f7rMW5TJXH4Jwvd+dttTt/45qSr9Nqd+6Wu3M4jin5OlUelde4pqXuOq1bza5T/X1RnRTXxHUav5JNLtPV5e9p3K/TZe5esPbb+944/z3lHil+9VEikbCamhqfsXZlZdahY8f4ZfLbHC1ftsxW1Nb6Z1VVVVZREc9wRfJ1Gve6N/nvaZzr3tXqOl2+3FasWFG063SnnXayMWPGNKsejGeN0iyK0tpJAYLKykpb7k6+u+++2/+UVg44WgQQQAABBBBAAAEEEEAAAQQQQAABBHIT6NGjR7MDoPFs8pebW0lvdeyxxza0aizpjHDwCCCAAAIIIIAAAggggAACCCCAAAIItKEALUDbELetX7rMdYG45ppr2vpteH0EEEAAAQQQQAABBBBAAAEEEEAAAQSKKjBhwoRmv3+ZG6sg0ey92REBBBBAAAEEEEAAAQQQQAABBBBAAAEEEIiwAF3gI1w4HBoCCCCAAAIIIIAAAggggAACCCCAAAIItEyAAGjL/NgbAQQQQAABBBBAAAEEEEAAAQQQQAABBCIsQAA0woXDoSGAAAIIIIAAAggggAACCCCAAAIIIIBAywQIgLbMj70RQAABBBBAAAEEEEAAAQQQQAABBBBAIMICBEAjXDgcGgIIIIAAAggggAACCCCAAAIIIIAAAgi0TIAAaMv82BsBBBBAAAEEEEAAAQQQQAABBBBAAAEEIixAADTChcOhIYAAAggggAACCCCAAAIIIIAAAggggEDLBAiAtsyPvRFAAAEEEEAAAQQQQAABBBBAAAEEEEAgwgIEQCNcOBwaAggggAACCCCAAAIIIIAAAggggAACCLRMgABoy/zYGwEEEEAAAQQQQAABBBBAAAEEEEAAAQQiLEAANMKFw6EhgAACCCCAAAIIIIAAAggggAACCCCAQMsECIC2zI+9EUAAAQQQQAABBBBAAAEEEEAAAQQQQCDCAgRAI1w4HBoCCCCAAAIIIIAAAggggAACCCCAAAIItEyAAGjL/NgbAQQQQAABBBBAAAEEEEAAAQQQQAABBCIsQAA0woXDoSGAAAIIIIAAAggggAACCCCAAAIIIIBAywQIgLbMj70RQAABBBBAAAEEEEAAAQQQQAABBBBAIMICBEAjXDgcGgIIIIAAAggggAACCCCAAAIIIIAAAgi0TIAAaMv82BsBBBBAAAEEEEAAAQQQQAABBBBAAAEEIixAADTChcOhIYAAAggggAACCCCAAAIIIIAAAggggEDLBCpatjt7l4rAxx9/bA899JC9//771rFjR1t//fVt7733tm7dumXNwpQpU+yiiy7y6y+77LKs25XSivnz59utt95qH374oVVVVdl6661nW265pQ0bNqyUspHzsZ5xxhl2yy232KmnnmpHHHFEzvuVyoaLFi2yRx55xN555x37+uuvfTmOGjXKdthhB6usrCyVbDQc54IFC3xe1llnHevdu3fDcj3Q9fvaa6/ZRx99ZIlEwkaOHGlbbLGFbb/99inbRfnJbrvtZpMnT7aJEyea6pQOHTpE+XBb9dhUZmVlZaHXfPvtt+2xxx6zzz77zNZYYw1fJ+n8ra6uDm1bCguWL19uL7/8sn3++ec2Z84c0zndpUsX69mzpz+nx44da/379y+FrDR5jKp3lNdZs2b5H+W3U6dOPq+9evUyXcdbb731anWeN4kW0Q24R1pZMNwjRfQEbeZhcY/EPVIzT52C78Y9EvdIBT/peMOcBeJ2j0QANOeiL80Na2tr7Y9//KNdc801psfJSQGIiy++2LbZZpvkxQ2P9WHujjvu8M9LJQB6ww032P/+9z/74IMP/AfRcePG2cknn+wDC1OnTrWddtrJdIOfnCoqKuykk06y448/3srLy5NXlfzjZcuW2eLFi23FihUll5dzzz3XBzX322+/jOeogoHHHXecffHFF6G8DR061H7zm9/YLrvsEloXxQUqp7/85S925ZVX2pIlS+yuu+5qCIAquKLz89FHH005dD3X9gqw/P73v7cRI0akrI/iE52L+nnwwQd9uV111VWx/fJB/p9++qmdc845PkimclVA7Kc//antuuuuvnh++9vf+rpZN/7JSV/I6MunzTffPHlxpB8rgPunP/3JfyGhvDaW5KDA/Y9//OOSC4bW19f7605fpH3yySeNZdOvUyB7woQJvq7abLPNmtyeDQorwD0S90jcIxX2mmvOu3GP1By16O/DPVLmMuIeKbMLSwsvENd7pDL3wSv1k1fhbXnHNhS49NJL7YILLmh4h86dO/tA6NKlS/0yBf/UQlAtydLT66+/bt/73vf84i+//DJ9daSe60OpPkz/97//DR3XwIED/YdyrX/uuef8euW7e/fuvtVOsINaSCroFuWkVlULFy7M+RBV/g8//LAdffTRts8++6TsN2bMmJTnUXuiwLxaC/7ud7+zI488MuXw3nvvPR/cDIL6almnclawMDi3tcMVV1zhWzqn7BzBJ2qpe9111zUc2d13321BsGSvvfbyATStVKtltXDt2rWrD64F12WfPn1s0qRJDUHThheK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coufqLZho28flFIAVL1nt912W9+TVoevCUvVw3T27NkN2dJ6xRUyzUlRSgHQuJYpXeAbTtV4PjjmmGN8M3TlLmhqrabZAwYMCGVYLSb1rYtmi7/jjjv8JEH6FkdB0hNPPDG0fZQWaLbs73//+z6IqwkofvjDH9r48eNt7NixVllZmXKoGoxZM2q/8sordtddd/n8Kt8HH3yw/fe///UTWKTsELEnlCllynXKdRqVaml1qnujYs5xIIAAAggggAACURFQF+lLLrnEH87GG29s559/vq233nqmCTE1JN0pp5xiM2bM8D0un3zyyZKeXPmss87ywU/FF5Svww8/3Pci1ZB7v//9732PW7XwvPrqq+0nP/lJVIoo7+OIc5nSAjTv06F0dlBFo0pI3z6o2fn++++f88GrwlK38Pvvv99f1Gpd2aNHj5z3L/SGv/rVr+xf//qX77KvoK2CoLkmBUIVPK2pqbHjjz/eTj311Fx3Lfh2lGlu5JRpbk6F3orrtGlx6t6mjYqxxfPPP28ab7k1klpsRzXpi1C1WmiNpPuPTTbZpDVeqk1egzLNn5Uyzd+sLfbgOm2eKnVv89xaey/q3vxFo1736r5Bn5979eplTz31lO95mZzLTz/91HbbbTffAOnII4+03/3ud8mrrZRagG644YY+AKrPNOplm55OO+00u/HGG/34pwr2pjc6K5UWoHEuU1qApp+1MXr+4osv+txstNFGeQU/tVN5ebldccUVpgtXXcqffvpp22OPPSKrE+RVLVXzCX4qQ5tuuqlv4apvbR5++OFIB0CDfFKmjZ+KlGnjPsVaG5y/XKfZS4C6N7tNMdc8+OCDdt1117XKIUT5Q/iSJUtabdibk046KdIBUMo0/9OZMs3frC324Dptnip1b/PcWnsv6t78RaNe96q1oNKuu+4aCn5queZnUMtJjXl5/fXXm4KAmjSo1JKG0VNLTyX1HM2UlE/FTRT0Pffcc/08LJm2i/qyOJdpu6jjc3zNF1CrTaXNN9+8WS/Svn17HxzUztOmTWvWaxRiJ43rGVykzc1rMGNblPMpS8o09zOKMs3dqhBbcp3mrkzdm7tVobbUeE764inuSZMBqkdE165d455VP4YXZRqvYuY6jVd5KjeUKWVaqgKr09/TmTNn+mLq379/1uI66KCDfExC83BokqBSTEE+NZ6pWrtmSppz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LqW8lDIt5dLLfOyUaWaXqC0lABq1Emmj4/n444/toYceMg2UrVnpNLGRWj9qXMxsSTPAX3TRRX61JkUqhaTBlO+991574403/DifauW59dZbW1Oz2P/1r3+19957z3bZZRf/Uwp5pUy3bLSYKNNGeYq6kuuUujc4AblOA4no/eY65ToNzkqu00Aier+5TrlOg7OS6zSQiN5vrlOu0+Cs5DoNJIr4W5MgkeIr4MYdSZxzzjmJNddcMzFgwICUHzfeRsJNGpQ186+99lrD9lk3itCK119/PeG67zccc3J+f/7znydcC9CsR3vIIYf4/S688MKs20RlBWW68jymTFeekVynUbkyU4+D65TrNPmM4DpN1ojOY65TrtPks5HrNFkjOo+5TrlOk89GrtNkjeg85jrlOk0+G6N8nbYrYuyVty6AwBVXXGFXXXWV6ZsnJY11GXR1nzFjhp/4R2OClnqaM2eOz4tmdVdSF/devXo1ZOvWW2+1Y445xurr6xuWleoDynRlyVGmpXcGc52uHGaEurf0zl0dMXXvynKj7i2985e6l7q39M7aVUdM3Uvdu+psKK1H1L3UvaV1xqYebVzrXgKgqeUcq2fqIn3JJZf4PG288cb2yCOP+MmPPvroI7vhhhv8hEcKjB577LF+PNBSzvxZZ51lGly6srLSzjjjDJs8ebK99dZb9uabb9oBBxzgs+Zau9rVV19dytk0ypQyLeUTmOuUurdUz1/qXureUj13ddzUvdS9pXr+UvdS95bquUvd+6ERcyjdszfOdS8B0NI9L5s88ueee863/FRLyH/84x+23nrr+X00c+AOO+xgt99+u3Xt2tXUGumCCy5o8vWivMFTTz3lD891i/YtPTt06OCf9+7d2weBDz/8cP/84osvtq+++irKWWn02ChTM8q00VMk0iu5Tql7I32CNnJw1L3UvY2cHpFfRd1L3Rv5kzTLAVL3UvdmOTVKYjF1L3VvSZyoGQ4yznUvAdAMBR6XRYrcK+26665+9vP0fA0bNsy3CtDy66+/3n9Lk75NKTyfP3++b/2pYz344IMzHrJaPyi/NTU1du6552bcphQWUqarSokyXWVRCo+4TleVEnXvKotSeUTdu6qkqHtXWZTCI+reVaVE3bvKolQeUfeuKinq3lUWpfCIundVKVH3rrIolUdxrnsJgJbKWdiM45w5c6bfq3///ln3Puigg2zzzTf3Y2O6yZKybhflFUE+KyoqUsb9TD7mqqoqO++88/yie+65x9yEScmrS+ZxkFfK1IwyLZnT1h9ocO5yna4sN+re0jx/qXupe0vrzDWj7k0tMereVI+oPwvOX+pe6t6on6vpxxecu9z3rpSh7k0/Q6L9PDh/41j3EgCN9rnXoqMbOXKk3//dd99t9HUU+NSkQY899pjdf//9jW4bxZVDhw71Y39qPFONNZItTZgwwXbeeWe/+pRTTjE3W122TSO7nDJNLRrKNNUjys+4TsOlQ90bNonqEure1JKh7k31iPIz6t5w6VD3hk2iuoS6N7VkqHtTPaL8jLo3XDrUvWGTqC6Jc91LADSqZ10rHNfYsWP9q2iW92+++SbrK66//voNXcdPPfVUmz17dtZto7iiffv2Nnr0aH9oTQVwzzzzTN9yUEHhyy67LIrZafSYKNMwD2UaNoniEq7TcKlQ94ZNorqEujdcMtS9YZMoLqHuDZcKdW/YJKpLqHvDJUPdGzaJ4hLq3nCpUPeGTaK6JM51LwHQqJ51rXBcG264oQ/2zZkzx/bZZx97++23ra6uLuMr64/pkCFDTNvuv//+JTdR0Lhx43y+NOv9pZdeanPnzs2YT+VReVXShEilNis8ZRouVso0bBLVJVyn4ZKh7g2bRHEJdW+4VKh7wyZRXULdGy4Z6t6wSRSXUPeGS4W6N2wS1SXUveGSoe4Nm0RxSazr3gQp1gKTJk1KuD+UiQEDBvif4cOHJ/bbb7+MeX7jjTcath0xYkTisMMOa9gv4w4RWrhkyZLEAQcc0HC8yq/7o5Nw431mPMojjzyyYVvXLT6x5ZZb+ucXXnhhxu2jtJAypUyDa5rrNEpXZuqxcJ1ynXKd8vc0tVYo3jPukbjv5b53QPEuwBzfmeuU65TrlOs0x+qiIJvF9bMMLUCjGHJvxWPafvvt7corr7QOHTr4V3V/XO2VV17J+A6K9N911102aNAgP1v6o48+mnG7KC6srq62G264wTQ2TpCmTp1qX3zxRfA05bdM3B8Zv+ytt96yKVOmpKyP8hPKlDLlOo3yFbry2LhOuU65TrlOoyLAPRL3vdz3RuVqzH4cXKdcp1yn2a+PqKzhOi3967RM4eOonFAcR9sJ1NTU2EMPPWQa+1LjgV5++eVZ32zhwoX2xBNP2IsvvmgvvfSSvffeezZt2rSs20dthfL4yCOP2Jdffmnbbrut7brrrlkPUcMCPPPMMz6fL7/8sh1xxBF28sknZ90+Siso08ylQZlmdonaUq7TcIlQ91L3hs+K4i7hOg37c51ynYbPiuIu4ToN+3Odcp2Gz4riLuE6DftznXKdhs+Ktl9CALTtjUv+HVQ5denSpeTz0VQG9F3A4sWLrXPnzk1tWvLrKdOSL8JQBijTEEnJL6BMS74IQxmgTEMkJb+AMi35IgxlgDINkZT8Asq05IswlAHKNERS8gso05IvwlAGolimBEBDxcQCBBBAAAEEEEAAAQQQQAABBBBAAAEEEIiLAGOAxqUkyQcCCCCAAAIIIIAAAggggAACCCCAAAIIhAQIgIZIWIAAAggggAACCCCAAAIIIIAAAggggAACcREgABqXkiQfCCCAAAIIIIAAAggggAACCCCAAAIIIBASIAAaImEBAggggAACCCCAAAIIIIAAAggggAACCMRFgABoXEqSfCCAAAIIIIAAAggggAACCCCAAAIIIIBASIAAaIiEBQgggAACCCCAAAIIIIAAAggggAACCCAQFwECoHEpSfKBAAIIIIAAAggggAACCCCAAAIIIIAAAiEBAqAhEhYggAACCCCAAAIIIIAAAggggAACCCCAQFwECIDGpSTJBwIIIIAAAggggAACCCCAAAIIIIAAAgiEBAiAhkhYgAACCCCAAAIIIIAAAggggAACCCCAAAJxESAAGpeSJB8IIIAAAggggAACCCCAAAIIIIAAAgggEBIgABoiYQECCCCAAAIIIIAAAggggAACCCCAAAIIxEWAAGhcSpJ8IIAAAggggAACCCCAAAIIIIAAAggggEBIgABoiIQFCCCAAAIIIIAAAggggAACCCCAAAIIIBAXAQKgcSlJ8oEAAggggAACCCCAAAIIIIAAAggggAACIQECoCESFiCAAAIIIIAAAggggAACCCCAAAIIIIBAXAQIgMalJMkHAggggAACCCCAAAIIIIAAAggggAACCIQECICGSFiAAAIIIIAAAggggAACCCCAAAIIIIAAAnERIAAal5IkHwgggAACCCCAAAIIIIAAAggggAACCCAQEiAAGiJhAQIIIIAAAggggAACCCCAAAIIIIAAAgjERYAAaFxKknwggAACCCCAAAIIIIAAAggggAACCCCAQEiAAGiIhAUIIIAAAggggAACCCCAAAIIIIAAAgggEBcBAqBxKUnygQACCCCAAAIIIIAAAggggAACCCCAAAIhAQKgIRIWIIAAAggggAACCCCAAAIIIIAAAggggEBcBAiAxqUkyQcCCCCAAAIIIIAAAggggAACCCCAAAIIhAQIgIZIWIAAAggggAACCCCAAAIIIIAAAggggAACcREgABqXkiQfCCCAAAIIIIAAAggggAACCCCAAAIIIBASIAAaImEBAggggAACCCCAAAIIIIAAAggggAACCMRFgABoXEqSfCCAAAIIIIAAAggggAACCCCAAAIIIIBASIAAaIiEBQgggAACCCCAAAIIIIAAAggggAACCCAQFwECoHEpSfKBAAIIIIAAAggggAACCCCAAAIIIIAAAiEBAqAhEhYggAACCCCAAAIIIIAAAggggAACCCCAQFwECIDGpSTJBwIIIIAAAggggAACCCCAAAIIIIAAAgiEBAiAhkhYgAACCCCAAAIIIIAAAggggAACCCCAAAJxESAAGpeSJB8IIIAAAggggAACCCCAAAIIIIAAAgggEBIgABoiYQECCCCAAAIIIIAAAggggAACCCCAAAIIxEWAAGhcSpJ8IIAAAggggAACCCCAAAIIIIAAAggggEBIgABoiIQFCCCAAAIIIIAAAggggAACCCCAAAIIIBAXAQKgcSlJ8oEAAggggAACCCCAAAIIIIAAAggggAACIQECoCESFiCAAAIIIIAAAggggAACCCCAAAIIIIBAXAQIgMalJMkHAggggAACCCCAAAIIIIAAAggggAACCIQECICGSFiAAAIIIIAAAggggAACCCCAAAIIIIAAAnERIAAal5IkHwgggAACCCCAAAIIIIAAAggggAACCCAQEiAAGiJhAQIIIIAAAggggAACCCCAAAIIIIAAAgjERYAAaFxKknwggAACCCCAAAIIIIAAAggggAACCCCAQEiAAGiIhAUIIIAAAggggAACCCCAAAIIIIAAAgggEBcBAqBxKUnygQACCCCAAAIIIIAAAggggAACCCCAAAIhAQKgIRIWIIAAAggggAACCCCAAAIIIIAAAggggEBcBAiAxqUkyQcCCCCAAAIIIIAAAggggAACCCCAAAIIhAQIgIZIWIAAAggggAACCCCAAAIIIIAAAggggAACcREgABqXkiQfCCCAAAIIIIAAAggggAACCCCAAAIIIBASIAAaImEBAggggAACCCCAAAIIIIAAAggggAACCMRFgABoXEqSfCCAAAIIIIAAAggggAACCCCAAAIIIIBASIAAaIiEBQgggAACCCCAAAIIIIAAAggggAACCCAQFwECoHEpSfKBAAIIIIAAAggggAACCCCAAAIIIIAAAiEBAqAhEhYggAACCCCAAAIIIIAAAggggAACCCCAQFwECIDGpSTJBwIIIIAAAggggAACCCCAAAIIIIAAAgiEBAiAhkhYgAACCCCAAAIIIIAAAggggAACCCCAAAJxESAAGpeSJB8IIIAAAggggAACCCCAAAIIIIAAAgggEBIgABoiYQECCCCAAAIIIIAAAggggAACCCCAAAIIxEWAAGhcSpJ8IIAAAggggAACCCCAAAIIIIAAAggggEBIgABoiIQFCCCAAAIIIIAAAggggAACCCCAAAIIIBAXAQKgcSlJ8oEAAggggAACCCCAAAIIIIAAAggggAACIQECoCESFiCAAAIIIIAAAggggAACCCCAAAIIIIBAXAQIgMalJMkHAggggAACCCCAAAIIIIAAAggggAACCIQECICGSFiAAAIIIIAAAggggAACCCCAAAIIIIAAAnERIAAal5IkHwgggAACCCCAAAIIIIAAAggggAACCCAQEiAAGiJhAQIIIIAAAggggAACCCCAAAIIIIAAAgjERYAAaFxKknwggAACCCCAAAIIIIAAAggggAACCCCAQEiAAGiIhAUIIIAAAggggAACCCCAAAIIIIAAAgggEBcBAqBxKUnygQACCCCAAAIIIIAAAggggAACCCCAAAIhAQKgIRIWIIAAAggggAACCCCAAAIIIIAAAggggEBcBAiAxqUkyQcCCCCAAAIIIIAAAggggAACCCCAAAIIhAQIgIZIWIAAAggggAACCCCAAAIIIIAAAggggAACcREgABqXkiQfCCCAAAIIIIAAAggggAACCCCAAAIIIBASIAAaImEBAggggAACCCCAAAIIIIAAAggggAACCMRFgABoXEqSfCCAAAIIIIAAAggggAACCCCAAAIIIIBASIAAaIiEBQgggAACCCCAAAIIIIAAAggggAACCCAQFwECoHEpSfKBAAIIIIAAAggggAACCCCAAAIIIIAAAiEBAqAhEhYggAACCCCAAAIIIIAAAggggAACCCCAQFwECIDGpSTJBwIIIIAAAggggAACCCCAAAIIIIAAAgiEBAiAhkhYgAACCCCAAAIIIIAAAggggAACCCCAAAJxESAAGpeSJB8IIIAAAggggAACCCCAAAIIIIAAAgggEBIgABoiYQECCCCAAAIIIIAAAggggAACCCCAAAIIxEWAAGhcSpJ8IIAAAggggAACCCCAAAIIIIAAAggggEBIgABoiIQFCCCAAAIIIIAAAggggAACCCCAAAIIIBAXAQKgcSlJ8oEAAggggAACCCCAAAIIIIAAAggggAACIQECoCESFiCAAAIIIIAAAggggAACCCCAAAIIIIBAXAQIgMalJMkHAggggAACCCCAAAIIIIAAAggggAACCIQECICGSFiAAAIIIIAAAggggAACCCCAAAIIIIAAAnERIAAal5IkHwgggAACCCCAAAIIIIAAAggggAACCCAQEiAAGiJhAQIIIIAAAggggAACCCCAAAIIIIAAAgjERYAAaFxKknwggAACCCCAAAIIIIAAAggggAACCCCAQEiAAGiIhAUIIIAAAggggAACCCCAAAIIIIAAAgggEBcBAqBxKUnygQACCCCAAAIIIIAAAggggAACCCCAAAIhAQKgIRIWIIAAAggggAACCCCAAAIIIIAAAggggEBcBAiAxqUkyQcCCCCAAAIIIIAAAggggAACCCCAAAIIhAQIgIZIWIAAAggggAACCCCAAAIIIIAAAggggAACcREgABqXkiQfCCCAAAIIIIAAAggggAACCCCAAAIIIBASIAAaImEBAggggAACCCCAAAIIIIAAAggggAACCMRFgABoXEqSfCCAAAIIIIAAAggggAACCCCAAAIIIIBASIAAaIiEBQgggAACCCCAAAIIIIAAAggggAACCCAQFwECoHEpSfKBAAIIIIAAAggggAACCCCAAAIIIIAAAiEBAqAhEhYggAACCCCAAAIIIIAAAggggAACCCCAQFwECIDGpSTJBwIIIIAAAggggAACCCCAAAIIIIAAAgiEBAiAhkhYgAACCCCAAAIIIIAAAggggAACCCCAAAJxESAAGpeSJB8IIIAAAggggAACCCCAAAIIIIAAAgggEBIgABoiYQECCCCAAAIIIIAAAggggAACCCCAAAIIxEWAAGhcSpJ8IIAAAggggAACCCCAAAIIIIAAAggggEBIgABoiIQFCCCAAAIIIIAAAggggAACCCCAAAIIIBAXAQKgcSlJ8oEAAggggAACCCCAAAIIIIAAAggggAACIQECoCESFiCAAAIIIIAAAggggAACCCCAAAIIIIBAXAQIgMalJMkHAggggAACCCCAAAIIIIAAAggggAACCIQECICGSFiAAAIIIIAAAggggAACCCCAAAIIIIAAAnERIAAal5IkHwgggAACCCCAAAIIIIAAAggggAACCCAQEqgILWEBAggggMBqKzB79myrqalpNP+dO3e2Hj16NLoNK1cPgVmzZtn06dOtQ4cONmLEiNUj0+QyRWDFihX29ddfpyxLf9KuXTvr16+fVVRw25luw/P8BN59912rr6+3IUOGWNeuXfPbma1jIcB9SiyKsSQywT1OSRQTB4lAXgJlCZfy2oONEUAAAQRiK3DsscfaPffc02T+FMwYNWqUrb/++nb88cfzQbRJsbbZoLa21s4991xr3769nX766Tm9ydtvv21PPvmkffHFFzZ06FDbYostbMyYMf41cnqBpI2uvPJK+/3vf2/rrbeePfLII0lreLi6CHz88cc2ceLEJrNbWVlpa6+9tq277rq2++6723e/+90m92GDthHIt95YsmSJ3XvvvfbRRx/Z8uXLbbPNNrNx48b5oHZTR9iSfTO99vDhw23p0qX297//3XbeeedMm7As5gLcp5RGAc+ZM8fefPNNe+ONN+zDDz+0vn37+i9Kx48fn/ULU32h9vDDDzeZwUGDBtlGG22UcTvucTKysBABBL4V4Kt4TgUEEEAAgbwFZsyYYfpRIE2Br3/84x+mG9LWSkceeaQpsHLAAQfYcccd11ovG7vXefrpp+2aa66xLl26NBkAXbZsmZ144okZA9ydOnWyG2+80bbccsvYGZGhaAgocKbWe/q5/fbb/fmqQEZrJuqN3DTzqTeeeOIJX2/MnDmz4cWvu+46/3iXXXaxv/71r1lb9rZk34Y34wECzRRo6/sUXUe/+c1v/NE9+OCDpr+jpJUCjz76qB111FGm+470pJ4AuhfRl+fpvQI+//xzO+aYY9J3CT3fe++97YorrkhZzj1OCgdPEEAgiwAB0CwwLEYAAQRWZwEF1BTczJQWLVpkH3zwgT3wwAM+mKZWQQceeKA9++yzmTZv1rKpU6f6AOg333zTrP1Xh53UCuriiy/OOasKNgUtK9QS7zvf+Y7N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i6WSgAQkIAEJSEACEpCABCQgAQlIQAISkIAEekBAAbQHED2EBCQgAQlIQAISkIAEJCABCUhAAhKQgAQk0J8ElurPYlkqCUhAAhKYCgKLFi0q/va3vzWeevnlly9WXHHFxm1cORwEfve73xW/+tWvimWXXbaYPXv2cHxpv+UIAvfff3/x61//esSy8ocllliiWHXVVYullrLaWWbj57ER+O53v1v85z//KR73uMcVK6ywwth2dutpQcB6yrS4jAPxJazjDMRlspASGBOBGQ8stjHt4cYSkIAEJDBtCRx44IHFVVdd1fb7IWasvfbaxZOe9KTita99rQ3RtsR6s8Ftt91W/PjHP257sG222aZ4yEMeUrndd77zneLzn/988dOf/rSYNWtWsemmmxbrrbdesfTSS1du37Tw7LPPLt7ylrcUc+bMKT796U83beq6aUrghz/8YbHlllu2/XbLLLNM8YQnPKFYZ511ih122KF41rOe1XYfN+gdgX//+9/FHXfcUdx6663p7957702dFk984hOLZz/72Y2//7///e/FggULih/84AfFP//5z2KjjTYqNtlkkyRqtythN/tWHfvxj3988Y9//KM477zziu22265qE5dNcwLWUwbjAv/oRz8qvvWtbxXf/OY3C/zAaqutluqN+Bs6xaqMDrXrr7++atWIZTNnziw22GCDEcvig3WcIOGrBCRQRcCu+CoqLpOABCQggUYCv/nNbwr+ENIQvi666KKCCmmvbO+99y4QVl760pcWr3nNa3p12IE/znve857i6quvbvs9brzxxmKNNdYYsd19991XvOENb6gUuBFL58+fX2y22WYj9vGDBHpFAOGM6D3+Lr/88uKYY44pEDJ6afqNapqID3vttVfxhS98oXIDOrLOPPPMJE6UN1i4cGHyG/fcc09r1Qc/+MH0/nnPe17xvve9rzayt5t9WyfzjQTGSWCi6ylf/OIXize+8Y2pdNddd11tp+M4iz+wuxFbdfjhhxeXXnpp5XegE+Pkk08unvGMZ4xa/5Of/KTYf//9Ry0vL3jRi15UUB/KzTpOTsP3EpBAHQEF0DoyLpeABCQwxAQe+tCHJnGzCgGRQ9///veLa6+9NolpRAW97GUvK770pS9VbT6uZT/72c+SAPrb3/52XPtP150i+hPBsmk4cVV0BWJTRFYQibfFFlsUf/jD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" width="672" /></p>
</div>
<div id="from-2010" class="section level2 unnumbered">
<h2>From 2010</h2>
<p>Now let’s compare that to starting with 2010 as the base year.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAPACAYAAAD0ZtPZAAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAVAoAMABAAAAAEAAAPAAAAAALYRw1EAAEAASURBVHgB7J0FuBxF1obPjYcES4JLggd318UX2Cye4ITFbXEJ7ra4uxPcl+WHxQnuEGTRxbNA0EAgJPnnbaihpqd6tHtm7s13nufenq6uLnm7u7rr1KlTbRNzYhIREAEREAEREAEREAEREAEREAEREAEREAEREAER6IAEOnXAOqlKIiACIiACIiACIiACIiACIiACIiACIiACIiACIhARkAJUN4IIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiECHJSAFaIe9tKqYCIiACIiACIiACIiACIiACIiACIiACIiACIiAFKC6B0RABERABERABERABERABERABERABERABERABDosASlAO+ylVcVEQAREQAREQAREQAREQAREQAREQAREQAREQASkANU9IAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIi0GEJSAHaYS+tKiYCIiACIiACIiACIiACIiACIiACIiACIiACIiAFqO4BERABERABERABERABERABERABERABERABERCBDktACtAOe2lVMREQAREQAREQAREQAREQAREQAREQAREQAREQASlAdQ+IgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAh0WAJSgHbYS6uKiYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAISAGqe0AEREAEREAEREAEREAEREAEREAEREAEREAERKDDEpACtMNeWlVMBERABERABERABERABERABERABERABERABERAClDdAyIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAh2WgBSgHfbSqmIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAJSgOoeEAEREAEREAEREAEREAEREAEREAEREAEREAER6LAEpADtsJdWFRMBERABERABERABERABERABERABERABERABEegiBCIgAiIgAu2TwMSJE+0///mPjRo1ykaPHm3du3e3fv36RX+zzjqrde7cuX1WTKUWAREQAREQAREQAREQAREQAREQgRQJSAGaIsx6k/rwww9t6623rjeZ6PxpppnGbrrpplTSarVETjrpJLvtttsKioWiZ8SIEQVh2hGBjkrg1VdftYsuusgefvjhSPEZqufUU09tq6++uq2zzjq25pprhqIoLCUCV199tZ177rkFqS211FJ21llnFYRp5w8Ce+65p73yyit/BOR+bbPNNjZ06NCCsHI7Dz74oA0bNqwo2qBBg4LhLuLw4cPtzDPPdLv57RprrGHHHHNMfj/+4/PPP7f1118/Hmybbrqp7bPPPkXhrRyQ5X17+eWX26233lpQ/VVWWcX23XffgjDtiIAIiIAIiIAIiIAIiECjCEgB2ijSFeTzyy+/2Ntvv11BzPJRvv/++/KR2mmMr7/+2j766KOC0svSrQBHy+2gsBs7dmxBueaaay6baqqpCsK0U5oA9/7BBx9sd911V+mIuaPEZRCEv2WWWcZOPPFEg7kkfQLfffddUZs0YMCA9DNKSLE9Pl+04fH33VdffZVQw+TgRRZZxD7++GPDGtqXf//73yUVoE899VTRNeP8Rx55xE+m6Pezzz4bPG+BBRYoitvqAdXct9XeY5988om98MILBQga+UwUZKwdERABERABERABERABEcgRkAJUt4EIiEDmBHbbbTd79913C/K58sorIwvFgkDtJBJAWYSF3H//+9/EOEkHUPZg2XbppZfaaqutlhRN4e2UwKT8fPXp08cWXXTRImUbriG+/fZbm3LKKYNXFYVeSGinUAxOMcUUocOGAjQuXbt2teWXXz4e3KH2J+V7rENdSFVGBERABERABERABCZhAloEaRK++Kq6CIhA+yDwxRdf2ODBg2tSfroajhs3znbcccegAsfF0VYE2iMBplbHBYvQ559/Ph4c7f/0009F1qd+xPjUfP9YSAGKu4NevXr50fRbBERABERABERABERABESgxQjIArTFLkioOFiiVNu5wgeoRAREoP0T+PXXX22nnXaKFjoK1aZHjx628MIL2xJLLGH8xlL0tddes/fee68oOm4IdthhB3vyySetZ8+eRccVIALtkcCqq65qp512WlHRUVZyLC5vvPGGTZgwIR6c33/ppZdshRVWyO+7Hz/++KONHDnS7ea3IQVs/qB+iIAIiIAIiIAIiIAIiIAItAQBKUBb4jKULsQBBxxQ9cIQpVPUUREQgfZC4JprrrGnn346WFyms19wwQU22WSTFRzH+o3p7ieccEKR71WsSS+++GJjERqJCHQEAgwAsOgXfm99CVlrcjxp+rs7FwVoSF588UUbP3580aE//elPRWEKEAEREAEREAEREAEREAERaC0CUoC21vVoaGlGjx5tr7/+urGqLRajM844Y92LpGSRZtZQUAjhVxHruJlnnjn669Il/GhgAfT+++8bi3X0798/+kujfPicw2KPhbDmn3/+qi1+42XgOuDLju20005r008/fbStZ7EolGosXIJvvd69e9sss8wSpVtPmvFyp7UPx3feecfefPPN6P6eY445bN55543K3NbWllY2Ed8PPvjAuIdmmmkmm2222eq+dn7hULag4AzJkCFD7OSTT7YQf+q4/fbbGwuzbLTRRkWnn3feeZElaCtZgbbCc1gEqkEBWTyv1RY9i7abdhJlI+3qnHPOWW2RKo7fqVMnW3nlle32228vOAeFJa4f8NHpS1wBOvvssxdYTL/88st+9PzvkEKVtpW2pVJJm3Mr3DuV1j0ej/aNNpo2lAXaaKdD7Vn8PO2LgAiIgAiIgAiIgAiIQC0EwlqeWlLSOe2CwGeffWZHH310ZFE2atSoojLTUR00aJDtvvvuiYtHxE/KIs14HrXuH3nkkfbwww8XnH7ggQfan//85ygcBVK8szvDDDPYLrvsYn/729/y53344Yd20kkn2b333ltgUYd7gk022cQOPfRQ69atWz6+/2OvvfYyFqHx5dxzz7XFF1888lHH6txPPPFE/jDKKzrka665pu23337RtOb8wRI/br31VmNhIRSfcUsoTmMxkPXWW8823HDDaFXwEknlD6H0vPzyy+2OO+6IOqo//PBD/hg/6Kwut9xytuuuu9pKK61UcIzzHn300SiMeyQuZ555pl177bVR8F/+8peoXPE41e5fdtllhsUkDJg6HhdcSaCs4HotueSS8cMF+xdeeKENHz68IIzp41tssUWk1PnHP/5hrDQdF1alHjZsWCqLovzrX/8KrjiN0oX7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REAEmkxACtAmXwBlLwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIikB0BKUCzY6uURUAEREAEREAEREAEREAEREAEREAEREAEREAEmkxACtAmXwBlLwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIikB0BKUCzY6uURUAEREAEREAEREAEREAEREAEREAEREAEREAEmkygS5PzV/Yi0OEJzDrrrDbvvPMW1LNPnz4F+9oRAREQAREQAREQAREQAREQAREQAREQARHIhkDbxJxkk7RSFQEREAEREAEREAEREAEREAEREAEREAEREAEREIHmEtAU+ObyV+4iIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIZEpACNEO4SloEREAEREAEREAEREAEREAEREAEREAEREAERKC5BKQAbS5/5S4CIiACIiACIiACIiACIiACIiACIiACIiACIpAhASlAM4SrpEVABERABERABERABERABERABERABERABERABJpLQArQ5vJX7iIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAhkSkAI0Q7hKWgREQAREQAREQAREQAREQAREQAREQAREQAREoLkEpABtLn/lLgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIikCEBKUAzhKukRUAEREAEREAEREAEREAEREAEREAEREAEREAEmktACtDm8lfuIiACIiACIiACIiACIiACIiACIiACIiACIiACGRKQAjRDuEpaBERABERABERABERABERABERABERABERABESguQSkAG0uf+UuAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiKQIQEpQDOEq6RFQAREQAREQAREQAREQAREQAREQAREQAREQASaS0AK0ObyV+4iIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIZEpACNEO4SloEREAEREAEREAEREAEREAEREAEREAEREAERKC5BKQAbS5/5S4CIiACIiACIiACIiACIiACIiACIiACIiACIpAhASlAM4SrpEVABERABERABERABERABERABERABERABERABJpLQArQ5vJX7iIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAhkSkAI0Q7hKWgREQAREQAREQAREQAREQAREQAREQAREQAREoLkEpABtLn/lLgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIikCEBKUAzhKukRUAEREAEREAEREAEREAEREAEREAEREAEREAEmktACtDm8lfuIiACIiACIiACIiACIiACIiACIiACIiACIiACGRKQAjRDuEpaBERABERABERABERABERABERABERABERABESguQS6NDd75S4CIiAC7Z/Azz//bB9//LF99NFH0d+ECRNsxhlntJlmmsn69+9vvXr1av+VrKIGX375pX344YcRk1GjRlnfvn0jFvCYeeaZq0hJUWshUO/9OH78ePv111+jrLt06WKdO3eupRg6pwkEuPYI14xr1x7l22+/tZEjR0ZFn3322W366adPrRpqm1JDqYREQAREQAREQAREoN0RaJ9fx+0Oc2UFPvbYY+2+++4rGxllyhxzzBH9zT///LbGGmtYW1tb2fMmlQiHHHKIPfbYY2WrC7OePXvaVFNNFSmrlltuOVt11VWtT58+Zc9VhOwJ7L777vbKK6/UnNHVV19tjzzyiF1yySU1p+GfOHz48EiJ54ehJLr55pvtoosush9++ME/lP/do0cPW3/99W2LLbaw6aabLh8e//H888/b3nvvHQ+uan+nnXaK8qnqpDKR//Wvf9kJJ5wQxeIZOfHEExPPeO+99+z000+3p59+OjHOvPPOa9tss42tssoq1qlT8iSEeq9/9+7d7f77708sR7UHvv76a9twww0N5SAycODA6LpXks7mm28eKYMnm2wyu/feewtOoYzHHHNMFLbrrrvakCFDCo5Xs5PW/XjTTTfZaaedFmV9+OGH23rrrVdNMSaZuP614118/vnnN73uK664YlSGFVZYIX8Nm16oKgvw7rvv2l577RWdtf/++9smm2xSZQrF0dNsm4pT7zghgwYNsm+++aZkhVCs853E+2yZZZaJvpsY3JLURqCad2xtOeisZhDgW+G1116zzz//3BjU4XkZMGBA9B1ZzeDUxIkT7ZNPPokG18eMGWPTTjutMTDUu3fvmqv1zDPPRIOc88wzTzRAXU1CfOsywE2Z6I8y2E+9JCIgAiLQXghIAdpCV+qXX36xsWPHli0Rcb766ivjBYagND3yyCPrehmWzbQdRaiUI1X66aefbPTo0Ubn6PHHH7dzzz03UkLRCchS+OD98ccfIysdlGOSYgJYMlXyPBSf+UcICqF603Cp8RHqCx9/dNL/+9//+sFFv8n/+uuvN5RKw4YNs7/85S9FcQjgY7nesjqrvWAGNQb65eLZShIUzZdeemleQZgU74033rCDDjrI+PBGYZT0EV/v9ccKN01BcUnnw8lLL70UXXssfMsJ15W/0ECVf4/Wc/3Svh/L1UnHLepAumfWWV6KS+sRSLttasX3d1pl4pvI3dOlrqRTgjz77LN23nnnRQM3O+64YzSoXOq8NI6lVdc0ypJGGpW+Y9PIS2lkT4D3ON9Ct9xyS3AwAeUnA+I8L127di1ZoIceesguvPDCqI/iR2SAF4MNBoqnmWYa/1DZ3/R3OA9hcHu11VYrew4RsJ6//PLL7bbbbsvPEHEnopDdaqutbN1113VB2oqACIhAyxKQArRFL818881ns846a1Hp6GR9//339uabb+Ytzh599FHbdttt7aqrrjIsjCR/EGBUcoYZZvgjIPYLRTIfA07xgIIDS9xu3brZ2muvHYud3u4FF1xgn332WZSPFKDluWJtUu29zUcmH4YLLLBAYgbvv/9+XqnFKHYp61//Q5UOC5ZxTvnJKPimm25qc889d3S/0YHkGOnfeeedkbKbc44//vho9H+xxRZLLBMHuP8Y5a9WJp988mpPSSU+gwdYwTqhfjw/MJ1yyint008/tQ8++CCyDH3hhReiaG+99ZZhrY2lYbkp1v369TMsaasR/3pVc15S3LvvvrvoEB3xnXfeuSi80QFZ34+Nro/yE4G0CGTRNrXi+zuLMi244IJFA1QMLOHuhQEXJ7Q/1157rb388st29tlnZ+7yJYu6urpoKwL1EGAAgW8CBnqThP7GlVdeGRld/OMf/yiaWeTOQ4mK8jMk9AX5/sAQhm8oZtZUKpxXrfzvf/+z7bffPrJmDZ1LP+qoo46K2oCDDz44ONgbOk9hIiACItAMAlKANoN6BXligch0yyThI/SKK64wPgQRpiNgYcbUUskfBJg6V276HB8jfLhjlcY0FeSMM86w1Vdfvd36UPuDQMf4te+++0auHqqtDdPykiwuSYsPVaeQ23rrrUs+c37eDDa8+uqrURBKz3POOSdypeDHcUrOwYMH2xFHHBFN56ejeOCBB9odd9xRUqHLx+zFF1/sJ9eyv7/77rv8FG4KiVLzr3/9a0F5sfZEGKi58cYbo04y1qRPPvmk4aqA8FKChftSSy1VKkqmx1DWvv3221EeKNW/+OKL6DcdCdwOhCw7My1QLPGs78dYdtoVgXZBoBFtU7sAUWMh99tvv0TFCjNY3nnnneg95VyeMN2X9xvvQ4kITIoEsKh0yk8GdvkWWnjhhW2uueaKvhtQWDIjiG9BXH3gUohBg7jwbeErP7HSxAURhjEvvviiPfjgg5EhDEYc9F0YgEiaTeOnjcU2cauRcePG2R577JFXfmJUwgA332TMoOP5/7//+z9DKXv77bdH0/PrceVTTdkUVwREQARqIZDsgK2W1HROwwjgO2+77baLrM5cpliCSqongKXg4osvHk1/d2fzUncuBlyYtiLgCPDx6QT/jfiRTRKUsGeddZZNPfXUURSU7P/5z3+Sore7cAYP8I+JMGgQV376FUJRiEKYqV9O+CBvdfGtP5k6hkUqghU3U+GbLbofm30FlH8rEpgU2qZmcWdGxkILLWRnnnmmMXjohO8mpxB1YdqKwKRAAMto5+Obb52jjz46Uk7++c9/tjnnnNOWXXZZ+/vf/x7NlnGzXnhWmObuCwpH3HE54flCscpgPspUBoyZccO0c4TvEAxiQsIgEIP1zETaZ599bM8998zPeAvFD4VxLrOZEL5jMbzZZZddon4Ta1AceuihhtWnEwZAmKkoEQEREIFWJSAFaKtemQrLtfTSS+dj+lOS8oEJP/DfhD+XWv3kcR4v3aSFXxKyLQrmRe/71SuK0MAALPn8RWqq4dlK9agUGVN1KmXP9Sa+5De/f0z3QZjiPdtss5XFQmfR942ERWFHEb8uyy+/fEXV2mijjfILIPnnV3RygyPxbLtODdfxT3/6U6TodcWoZTqZOzeNLRbsjbwfyQ8L2LhP3GrqUu/7x8+LBVuwpiknrdhGY0VXD8d6zvV5tSIbv3y1/vbblma3TdyjTCPlmqchld73aeRVKg0G4xkUQsnjxHeH4sKStmm2BUl5uPCOdJ+nfT/V2xY5xvVs065To5+Rf/7zn/nqo7REORgSXEv4FpIPPPBAQTQGXGkrkEUXXdR22223guPs4BIIpaibfcJaEKH3AS62/va3v0WuvXAHEn9XuvOLMvg9gPi+chUXYSG3Yuuss06+vszuefjhh5OSVLgIiIAINJ2ApsA3/RLUVwB8DzrB116SoMAaMWJENP105MiRecUlH69YM6200kq2wQYbRNM0ktKg48v0Bqbaf/TRR/lRRHwVsio9U81ZebacYDHFCx4/pkwB4QU7xRRTGB2UjTfe2Pg4aJYwSjtq1Kgo+3IKv2rrgdKAqbwI01YQPsjdx82SSy4ZjewSzofUPffcw8/IsTgrrSYJo8yUGUtWrDF8wRoDX0MIU3Wx2GDaMRaJKE3wNYtTc4TpbtSZ6cqMEmOpyFQdrGhef/31qOOGT1XO4Vqz6nGScM4TTzwRHeb+KueGICmdVgyHNdcN4ZmoVLiGTF1CKllkotJ0mx2PtsBJ/OPahce3tFtM6cI3KEJHpZQVbfz8Ru7TaXCuMVh0gI7HmmuuGT0blOPf//539Ozgt7UZ0qj7ESsQ2gPabDpaXEPaAtotXK+U6kjV+/6h3aT9nHnmmSNLE5QmtGGsws4gDi5LmB4Yl2rb6Pj59e5j2XPzzTdHyWB9w3uS9zDlZrowrmscR1xmYNnjLINCeWPNwwIUnMsf9yXv31VWWcU233zzqvwG18KG94BvmTR06FBbYoklQkWN6nnDDTdE7yXqyDRNto2UNNumat7fro6cw/VneijPqWsf4cC9gLU8SpIk/8bl7nt87jnr9HLfFK5MWW1Z1MUNBmFxxncGFm9xqbUtqIU/eddyn/tlbqVvmXrup7TaorS+TR3jeupEGuWekZNPPtluvfXW/LPHM+NmcLgy+Fu+RXDjg/BOP+WUUyp2hUWb7IRvhFLCe9NNRceVhC+PPPJIfpep5knvVgbfmVrPjCJWmue54xs/TWEQibYLwf0P5U4S6sy7DUEhW8r9VFIaChcBERCBRhCQArQRlDPM45VXXsmnzgd1SPjoxoeiU0j5cfgYZaSRj3T+DjjggEgJ6cfhNx0vpq06SyP/OOfzxwcvo574VUQZFxc6zSjbsA4gX19In49nXpqUFUVoM8SNupJ30sqKtdYD/zjx6b6k5cL69u2brzKKIRfuW1bkI3g/+OhhwZ2QAoZOkUuHRXr44IorSV1S+MJ0Fr0oybkOuALwhYVs+OMDjWkuSUpQyuQUq1jWdiQFKFbCrMDJ9eR+gZvz9+mziv/GX1Iz/VjGy5PWvm8By/OLJUDo+Y/nd9xxx8WDWnL/rrvuypeLuiEsrIUVhLOCf+yxxypeSTWfWEo/sr4faaPoRDpFnis2ikfaFv5or5IWPkjj/cN7jumFKPxo03gX+cotVya3rbWNduentaXj6Npfyo71DIpkX3yOtK100BmYjAv3GtMnieML7K+77rqo48lq3OWkHjYovLGCdh10ZkkMHz68aOVv3ufU1Snl8B/XaOUnHNJsm6p5f5P3888/Hw0kusEywpxwzbmn+bvmmmsiX3+hAaBy9z1pu/vLpZ30TeGOZ7XlPY9yxJWHqb1xBWg9bUG1/Ou5z31GrfItU+/9lFZblNa3KYzrrRNplHtG+C6mv+HuS9zF8C2cJFguurjM9qjkW8al5fcfMBYoJf73PkpXJzwjKN2drLjiiu5ncIv7LudSCTdocQUo1ps8C76w8FKlbiqcj3zOL2fggrUqylrXBmFVzPtCIgIiIAKtRqBYS9VqJVR5EgngaNuNIPLSSVoAiRUCnfITK1F88KEs7dmzZ2RVQ2fG+Q+lo0ungZeqE15mjLI65ScWmihyUALQ0SEcq1BedizGwerLWBvGBef4fFwgzooKa0N8xTByykcHH7mUAcuYvffeO3HkM0ok5X+4BHCdS3jGPyRcdrXWAwflbtoLShU6QXR03cdYNas4urJUs8XyCAteJ1jdOr+ULowtnVo6rChDWRUdCxWUwShZSQOlKGUnDtZIpSyP/XQ7ym8+iFEEOGtO7lNYrLXWWtasVdibyZZ2wAkWx1gSM+WqmZbcrjz1blHgMLCDYGnnt4s8F7R3CNbaWLQ2Q7K+HxnIQPmIZSIdQtopLJ9RDGAdi9Cu4A4CC8a41Pv+8dOjI8sgnVN+0n7SNvHO8aXWNtpPI+3fp59+urkp2cx2GDhwYJQFFmooAhAsBbFyjb8/aXsZWHQKRZRlWF5i/cO1oTNL5zt+XpRo7F+9bIYNGxYpHfD7izIEpSuDZb5wzV1Z6RRjHdgMSbNtqub9zf25//7752cKMMOGa44/aN6dLKiGIpxrhm89Bg/OP//8RERJ9z3vm2Z+U8QLTPvolEchF0L1tAXV8Kdc9d7n8bo1cz/t+6metigtDmnXKekZ4d2AEYHz6c90c/fNHaqLPx29nPFB/Hws8ekb0b+Jv5PicX2rT994hXDaCKR///4lrVWJ47dxWIHGhUWT4lLNYJT7ziWNJGt/lz59CspMP4rrgXUv+xIREAERaDUCUoC22hX5vTwoAF2nyC8iCkJGC+k00VliyjId07322iuauuzH5Tejic7ihBFHVlyOT/9gmsIVuVFCZz1Ch9/v6KPgdB1dOsAnnXRSPJvIYpMPcV7cWKOgjPWndaFgdcpPXvasfBh/MTKSi4ULaTDVktHGRlnM0Vljip6z1kCZRWclLvXUg04r0yARlM7UE+WFC4vnlfa+U35uttlmUYcUhU5I6NQiLGiDssG3TKFTg3ILJSgKUhSizirOT4tRX5d+SMnqx63kN9YLTL2tRPgIS7LereT8SuKgaMBNAL6OeAZR2tO5Q+nHRyLPD0pS/xmoJF0XhzQrra87h+fbv1YuPOvtIossEj2rro1gsIU/rj8WQfAgTuh5qrRs3JPV8EAx5lt/VZpPPB5W6bShCJ0hfyqarwClvs2cxp/l/YiCjU4U7b7fUYOJb1HOVNy4AjSN9w/5OHGdRpStKOJYEAJrbF/qaaP9dNL+jfKT5xNlF+9RX7DKd4OZ3HNxRSaLTvgKRXy/MTjlhLb4iCOOMCyRncStfghPgw3tOXXg3YDceOON0SCZGzCkHXDuW+hoJ1m0Ridn/C/Ntqma9zdKFDebYvvtty9Y9I0qc/2Z5cKMGZSgKBlo8xmUDkmp+97dS834poiX1b3zCafd8KXetqAa/mnc567saX/LuHSr2aZ9P9XTFlVT7lJx065TqWcE4wz6HPSf6DvRlvoWmK6cvMOfe+65aJfBhUr9BrvzWRioEqGfQT/JCd+KTtx0c/b9Nt4dj2/97+v4jK143Fr2aymPMyShPPF+Xi1l0DkiIAIikDYBKUDTJppSerwc/RdkUrJ0yOmYYmEQEqwLeOkjKLTiyk93Dr6onALUWam4Y1iaOvEVoy6MLdMwUQigZONDHosVrDsRrIXctGtGRem8hV6KdKDwZ+msSehQ16sA5WMmyU8jI5S8oBmJptPm4q233npR5zoqvPevmfXwilHXT5R2W265Zdk0UFwdf/zxRfFQYuFU/bLLLouOcW+EFKAbbrih8ZeW4O+Pv0qEe9n5cKokfi1xmPLOFE9Wv0QJinB/0JHl7+KLL44GJpgWiAUUH9JsK51OxZQmFNXVCIp0Zw1UzXn1xqVO3CtYwvqDNnTs8RfmFgagw8Ezzr3FtC5/wbFyZQjdi6XOwVrIXxm9VNxSx5x/PeLE73PaNxSDDFbRuccXaLNcd2R9P3Kfx5WfMOEexQoWa0A4oPSBvZM03j8uLbdFycJAXsjautXbaPzJobSNCx1nBv24j1D2M7OCgRyEd6m7l3mGeJfGB1ZgTgcfP948dyFJkw2WTizqxrONovWYY46JFLi0hbzfnWAFOf3007vdhm8b0TaFKoWvVITB6ST3Lyg3+G7DtQTfIliFOiVyKM1S930ofjPC/DY9bgGaRVsQqmOa9znpp/0tEypzubAs7qda2qJy5azmeBZ1SnpGUGKvvPLKkYst2iuMMViIMS4MItAGI/SXyllxxs+vZJ/7kzaS5x2hHfAt5J2/cY5VMrvKfw9moQDlXeTEvZPcfmjrl4fvAokIiIAItCIBKUBb8apUUSZe5lhj8DJnMZ24NQwdo8MOOyxKsdT0Bd+yySl0XDH8fRyp08kKfRgw9XXXXXeNTvM7wZyDkhFBuTighG8cfEZhBYESlfPiHeookSr+kQZ/lcqgQYMipVYofjPrESpPtWGzzDJLxQqyUiPZTLt04n+subBJZYsS4I477ogsoFBQoKjwhQ9pFMT8MZjBxywWcky/Cj0//rnt7TcKGaZwYhF8yy23RFYU8YWesLpwzyMWszzrrB7s30+tVG+um3P7wbTvkEUpTv8vueSSqNhYvTVLAUoBsrofUVhjSRcSLG1pz11Hh63f9qfx/onny1Rwv5PlH2/lNpr7PaT8pPz4qWNQ0N1vtKuus4mPTWfNyeBVXPnp6k+bwqJEoRkaxEmbDQOVTHdG4Urbx6APHXCmPSK4hIgPGkQHGvyvGW0T3zkM8nANfQuteNX97y43+yQex+2Xuu9dnGZv/ZkXtP8oe9ygXxZtQai+ad/noTwaHZb2/VRrW5RmvdOuE2Ur9YwwgwMf5QjWpyEFKOFOqp3+7s4rtcUyksEi3Mc4YSaDP3OnWoWjryT1fYm69OvdVlse994iX/ddUG8ZdL4IiIAIpE1ACtC0iaaUHn46Q86vnYUIHQ6mfGDhyIcz1iN0nliYxhesL0qtxMcHKlNL8QmUJL7VJxZedLL4eKCD47/s6MTxFxfXqSPc91cTj8c+H8vkh0UmlquMkmI51yjBrQDTUULWi+2pHiFecHWdkdBxP8z5p/PD3G9fge2m+bljWW35YA9ZDYfya6TvSSyyUBbzh/8l/EzhyoE/Nw3IlRGlBtZbb775ZvQR7MJDWyxpGGioRhpZ76RyYenKH20SjvyxhoUFPn6dXyt3Lq42cLCPAtFZi7tj8S2dJXwjViqhdqjSc108f/GjpM6QrwCljlhBhnxuuTSz3mZxP5Z77nyFZ7w9SOP9E2e29NJLx4Py+63cRpe7x30FqM+R9sJJOT+zpWZMpM2G6860ewZeEaxysWREmGmCS5lWkqzaplAdk2bkuLi8C3B14FuYu2NJ21L3fdI5jQ5n4NoJSh3/eyOLtsDl5W/Tvs/9tJv1O+37qda2KM36p10nylbqGeEY9yRKQr474i5reCad/1ru1aTBqloYMBiAmzFmS9DnQrBKPfLII4tm7/kDIUkuMfwy+IMoaXz3+Gnz2y8PZS4nWZenXP46LgIiIAKVEJACtBJKTYiDtVGpzowrEh/RTA9FWYjyBYs0pgDHBQsSlIkoMOlQsaIsU+2w1nDWJfFz3D4dM3ySXXjhhVEQ03OZwsGUO6y3sCxdbrnlIiuh0AvYt4xjirybzufSj2/9+CxMVI9st912ke++UBp01uho4qsKqzUUNXCkXli9xqcT++VqdD1C5a82rFIFEh1bv+MSz6fUsXjctPZRgOFioZWFj2YsiPlD+MBGyYcyn3veTa1CyT777LNHAwlJ9SEt7t32Klij0S44q3OeNSwq8ZVJ/VEUIjxvWJJdeeWVQZ9crv5rr712Re2hi1/vluffWYuQFu0EbUTY0ehPAABAAElEQVRIsEZkITck5L8xdE4jwtK6H/G3WUqwAi0n9bx//LSZ4eBbmfnH+N3KbXQ5f25J7aqbSgznJBc2joM/BdmFuW0WbLAOZrD2hhtuyCs/ye/www+vaPqmK1sjt2m3TaXKTruAsoWBINo8vrv4wydhNVLuvq8mrSzj+t9rSfdqWm1BUj2yuM+T8mp0eFr3U61tURb1TatO5Z4R2lcGLPFZzPcIlsL+IDN+Y903Gt8bviKvnnrzTYBhirOMJy0G9PGhHPKL7l+bStoJvqGc+JakLqzeLRbszq0K5UmafeHy8WcMZlEel4+2IiACIlAPASlA66HXAudimUQH6aKLLopKg9VSXAGK4hOlnj/twi86fqp4IaOoSRIWvqEjjLWWm87OhyzKUP6Y4svoIHljIeq/+Jyyg7STypCUb3wabVK8pHAsospZMGE5t+qqq0aLEbkRYBSccQVoM+uRVD/CndVNqTgcq0RRQTzfoot9SW0EeAZ4PvnDOhQ/iijZEZ4XnpNJRbj35p9//uiPtgTLp+OOOy4afOHjmqlnpVZmbTQnFpPxp3659rVcOVpJARova633oz/FLp5mJftpvH9cPuXasFZtoyl/NSvvuvqieMcyCUGhlKQkdfEZgOR6uXNcONus2OC/DgWoE6zLlllmGbfb8tss2iasvK655hq79NJLo0GeEAS+p7gneD7KSbn7vtz5jTru/DqSX0gZn2ZbkFSnrO7zpPwaEZ72/VRLW1RLPUt9m6Zdp0qeEb7FUIAiDEr7ClB8eDtBAVqvMBiAhadbfZ70eOZZ6NUtXBbKgz6LE38mgAuLb/2ZNaXcbcTPq3Sf8jgFKOUJPdd+WlmXx89Lv0VABESgVgJSgNZKroXOY2qH66DjaN4XpuFiSeZGCRnVZHozi2ZgEYilKQu1ICgBkaSRT6fMYZEklKVMv0eh6Ub8GB3EXxkWD1iLuukSKFidMB2/mpc0lnKNEEaPsWRxClCsQlHw+ixatR7uI4nypiF+ndNIr6OlgfKO5wlOKPz9+yKprljjsegA1qGci4ICC+xy1nVJ6aURzsCFG5DANUXStLhSnRjcZ7CqKkK7gpKznNBRgQNtlVv5GuvQVhJ/+ns15eKaMvU/zelz5fLP+n6spz1I8/1TjgPH/Wex1d41tXD0z3Hv8FIceFbd+yAeLys2p512WkFWfB/gD7fZ/j+b2TYxK8ef3o5Smu+0OeecM7L64psLVxm4HnIKUP9aFwBtJzt8f3DdnTCo7kuj2oKs7nO/LpX+TuMdS15p30+NutdcWxT6Nk27TpVcE75P8IWPEQf9F77DeDYZ7HSKSp7NevsdTz31VOQexPnAROHMwC99jHL+330L0Ep8ejK47sQ3PHFh9W59hayrT6k0/fJU09crlaaOiYAIiEDaBKQATZtoE9LzpyTwwcHIqrMUweG26zjhcwcrtNBLMmQxklQVFCX88UJH+cn0LkZTWRGWfTpAKDZ22GGHKAksMJ2CAx9mTJdvRfGVFtQDlj7bVqwHHV7fUq0VuXa0MmFB4PzysTK2f9+Uqisfg3xYu2cBBWAzFaB88J911llRkfHjl6QA9adhxT/eUfi5RVeYDnvuueeWQlBwDJ+0TgHq+20riNSEHSw36MAgDIxgyRWvd7xYZ5xxhj2cW1kWQQlQ6T0RnVDnv1a+H7N4/5TC1YptdKnyljtGx5kOKAuI8Y5mRkTSIkikxSJEbhpnPO0s2HCvu/ueAU/XVjDYw/NdzlooXsY095vVNj399NN55SfXCkt3/I+GLNRKDS6lyaIRaTHwzfR+J3Ert0a1BVnc565O1W7TeMe21/up1LdpM+uEIQcGI7STrPrOYKy/+jvH6xEGlffee+98O4wrM/pdDIJXIr6LF74zKaev1I+n4Vs8s1hj2uKXZ+TIkXm3RqF8KKtz2YJieYYZZghFU5gIiIAINJ1AeeddTS+iClCOgD91nReOU37SWWJhDoTOCdPgQ8pPjjNS7SQ+WouFF75DUWzGhSl3WDawEj3pO+FF6cRfFMR/Wbvj8S3KEPLjzylv43Gy2OeF7XdS4nk3sh7+CH0pNwBck6QObxaMlKYZSk8nrHpejfj3FJYIzRTfwX6pe8wpNShrfETfZ8FAiB+3XN2c5Tjx/Ger3HlZH2cau1NM0ImnQ42iutSfb+3GVDp/4YCsy+tfg1a6H9N6/1TDz7+PWvldU02d/HbCf0+H0mBhxCRJm82oUaMiq3aX38knnxy50mGfaZBHH310Wf/i7twstv5z0ci2CcsyJ8y+YTFL/7vCHWPrX8/4d5cfrz38vu222/LFZOFKX3HSyLYg7fs8X6kafqTxjm21+ymNb9Nm1smf3u5WfXdbntO11lqrhiv92ykMUrGqu/smZ+0E/H9WqvwkFVyduEVIWVTMWYgnFYqBByehhXPdsVq3K6ywQv5UZreUEhS2biG0pEGfUufrmAiIgAg0ioAUoI0inVE+WHv6vmt8yyNG4txHNZ0BpxgNFcVN/Q4dw5qDVa55mftKi3hcpjy5D3039YU4boo9v7ESLSVYM2I5Sn6HHXZYWcurUmnVcsz/YPWVVaTVyHqgjHVSqlNbjqdLQ9v0CPgda99xfrkcWJzBWTpiWewrNsqdm8VxP3/fcieel3//+dOhiMeAi3tmaIuqUcC5TgfpVDJ1nniNEH/qqt9ZKpU3bZ9z+cGiDv6gVKnz0jjWqvdjWu+fahg1so2uplz1xHWdYdJIWojLpe/74nRhbpsmG74rUHA6f28sUoelE51/51+Qb4qbbrrJZd/wbbPaJucjnQr71y4OAEWBc0ESP9be9nF95C8ax4wCXxrZFqR5n/t1qOV3Gu/YVruf0vg2bWadcP2F338EC10sxd30d4w5khbvquT6094xMIRsvPHG0Sy5Ss6Lx/GtUC+77LL44fw+081d2ZldFFpUKR+5xh9827hrziKWbvZTKLk777wzH5yFMjafuH6IgAiIQJ0EpACtE2AzT+flh1LSOZ5nmoSbdk65/OlnWMPEFXqu7Cz4cf3117vdoq2bVoF1F6taJwkvRmc55c4hLi9Cp+DAYvH+++9PSsLOP//8/IrKjMQ6hWriCSkfcJ03kkWR4Uua9XBTWhgpdp1IPy//2jFa7kZV/TisYukcuvvhrfAbyxY66/z5iq5WKFu9ZaCz7xSBKDT33HPPaMX3UunykX3CCSfko+Bz07ekyB9o4A8sG50wBSzkBoOOK9PVnKDk8IU6bLvttvkglCKs8l5KUJ7ceuut0bQzFw8erSBYrjs/yvjiokNUiTBVHhcjTrAibZS06v3ot2H1vH+q4ZhmG11NvlnG3XrrrfPT3hnsdD5343nSES41AJEmGzr6btCU54SFPRCuufvN/tlnn23+qtyENUqybJtKvb/9aZ/+4JFfb76lfEsx/1itv0uVqdY0y53H4ihM8ceXqRMWlllooYXcbrRNuy0oVdc073MKX8+3TBrv2GbdTwUX0Nvxr2Wt36bNrpNTMPL9zf3L4C2y7rrrejWt/qf79mFQeNddd60+gd/PYLV61/fBxQjf+nGhDTniiCPy1qZ8B2QhGM6sscYaUdL074499tg8Lz8/yugUoLwT4j6A/bj6LQIiIALNJiAfoM2+Agn533HHHZGT7tBhFHMoXr744ov8YT4I999//2hhIxfIat6MhvMBh3KDaerbbLNN9HGKMpTOPpZKrEhNZ4E0+CDABx7H6dQjLPTiXmxHHXWUHXDAAea/oHHUzTQMtxgCabkXJuezzzkoSlB+YNmJQsh13Hmp0kmis+Qsp5huio/RRouz4iJfRnJ9C44064HCh4WW4M0UGRbswD2B8wmJogn/YUwdQ3mwzz77RKuGY+3FlBg6uyiREKYlV+KcPIrcoH+Uz/mX5B7E92tHEa4TH54oPhEUAdzbrGLO9eGPD0CsKj/44IPoOcOPpJtmjoUBz0MpoeMct6IpFd8d477CeroSmXbaafPtA0r4PfbYI1JecL2w4GZghWfSDQRgORHv2JIPbQoDIyhmaDd4vrn+SyyxRMRiwIABkeU4zzg8aEuYkuqE88spQLmXnBWCO6+SLZz9Tmi5c3zrT9o419Eudx7HafPuvffeKCrtGG1uLWWuJC8/TiPuRz+/Sn+n9f6pND/ipdlGV5NvlnFpL1CC4rcO1wo8p7zr8aXNMWZNMKh46qmnRsXgvR0a7EyLjXtXuzrvu+++Bff5+uuvH81KoQ2gHKyEfMkll1T1LLm0691m1TaVen8vssgied/GXDOUISwwyXuaASXaPiwmeY/714pj+E2tVUqVqdY0zzvvvAI/6C4dfNLyfkMB6ga9OcZ0WfwfxiXttqBUXdO6z10d6vmWSeMd26z7ydU/vk3j27TZdVp99dWj9pLvbzeQg/HDyiuvHK9uxftYtbrBHvoRLPJUqTCgTjvqhH0sSJ2BA2nRj+Mbg3uKqei0qc7VGN84LLCUlWyxxRbGoC7fiZSD/gh9Fp53+nIY0VxwwQX5toBvY78vlVW5lK4IiIAI1EpACtBayWV8HguluMVSymXFaCovSGdl6cfHygBFIi96OuX80WFGqUEYwj7nowjlOC9yPhBQUB544IHRdJGNNtoosuZDMXL44YcbDu3d9B43rdflizIorijBIpQP4zPPPDPKl8VS+KNTwEim32HjQ4Ty8NHcaPEXPWJ6efyDKK16sGCMU5Y4S0mm22JBh6D85NrReaSD4XyixnnQweN6sQiVpHEElllmmUgRwUcfSgk+AlkIxwmj937H0IXzrHHfl5uqxIem+zB351aydYMWlcSlo8hzjHKF5w8L7iTlKcpPOsOcExfqysAIShk+jhFWUXcrqSexIN4mm2xSkaLXpcs51QhtS6UCA2fBwTm+X89K0uCeoM2ijXSuSWg3GyFZ34+11iGN90+1eafVRlebb5bxt9xyy+h7gI4m9ylWOAjtib9SMO96LHF4J4ee1XrZ8M3AO8m9r+kA+4OdjsEhhxxim222WfRup5N+xRVXNGVAM6u2qdT7m28GrBC5Vgx6sUgcboS4VixS5QQrtA033DA/a4dryjuE2TgoOaqVUmWqNi0X37f+d2GhLVZitOUoPpIGjdJsC8rVtd77PFTHWsLSeMc2635Kqm8a36bNrhPPIhaK9Hec8P1dzfeTO89tfZ/TDBD4rslcnKQt34O+ApR4PEu0nfwxmHrppZdGf/E0qAttR7mFGuPnVbNP+VjIiT/eASwSyR/3t3Oz5tJjAKzabyd3rrYiIAIi0CgCmgLfKNIp5oNVEU7mGSHEwgnrspDykyznm28++8c//lEwHZ4Ok1N+YqV19dVXR9ZadLLcBwAdHH8hj/322y8a9XNTxDlGJ8tXfjJqyQuSafkhGTJkSNQR8i2ysFx0nSnOYcopK0NT7mbInHPOmc+WqSehKYVp1GOVVVYpa+3BBxnTpkOKYCwMUU4zzSakaMtXQj8yI7DVVltFPu5C1q3xa8IgBdcKH32zzTZbZmWqNmHKwqAEHcYkwQoaS6ZSjvyp31VXXRVZfzr3AC69OAs6yCwuhOUz7UqrCP5cne9irFZ96+9KykgHhOfaCStkN1Ja8X5M6/1TLcc02uhq88wyPkoH3uO8W33FplN+chyrnB133LFsMephc+WVV+atjvgW4B0UEtoDLFWdYK0UWkTRHc9ym0XbVO79zYAQFlJOaAOd8pNBVto94uCz3V9khPYnrlBwaZTblitTufOrOY7CE6UIFqvccwx2McCdpPwk7TTbgkrqWs99Xg2LcnHTeMc2434qVa80vk2bXSc3Dd7Vk5lu9Yjv17SedNy5LDDLADvlSnqusKS9+OKLbZ555nGnZbblO5dvNtpTJ35bRT+Fb1wGOiQiIAIi0OoE2nIN2MRWL6TKVz8BfEjirweFJb/x44Py01lxuhyY/s6II5YTfLDGlRkoLF955ZVoKhdTtuiMYR3mPoYrmfaAdRR+9rA4ozx0pLB4oDxuCrgrTytv06gH0+yxHqQDy4cy27jwiMIai2CuHQpkPnhCcePnar8xBLg+3NN8BPOH5Q/PGEpDnjE+VHmmWllwY/Huu+9G5ee5RwHIfYaFQTVC3bHYxMUDLLi/p5hiiogFPLAO91cIriZtxa2MQKvdj2m9fyqr/R+x0mij/0itNX7xDmbxnNdeey16P7OgB24rSi1yGCp5R2QTqqcflnbbVO79TXvK9xTtIG0gAysM8qLccMJgNO5G8OlO+8hgdj3vinJlcvk2a5tmW1BJXVvpPq/3HduM+6nUfZLGt2mz6kQ76lZ85zsHQ5BWFdydMUCL2wkWoqWfxHdUMwxFGMzBMpz+G/1Fvg/pA2LVW0n/r1UZq1wiIAKTFgEpQCet663aioAIiIAIiIAIiIAIiIAIiMAkSeC2227LL0yJy456LUAnSYiqtAiIgAi0UwKtbZLUTqGq2CIgAiIgAiIgAiIgAiIgAiIgAq1F4Oabb44KhGW2swRtrRKqNCIgAiIgAlkRkAI0K7JKVwREQAREQAREQAREQAREQAREoCUIsGjo22+/HZWFtRTkTqolLosKIQIiIAINI9ClYTkpIxEQAREQAREQAREQAREQAREQARFoEIEzzjgj8kfOQmMvvfRSlCvrDwwePLhBJVA2IiACIiACrUJACtBWuRIqhwiIgAiIgAiIgAiIgAiIgAiIQGoEWEjo4YcfzqfHyur77befTT311Pkw/RABERABEZg0CEgBOmlcZ9VSBERABERABERABERABERABCYpAnPPPbex4nzPnj1t9tlnt0GDBtnCCy88STFQZUVABERABH4joFXgdSeIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAh0WAJaBKnDXlpVTAREQAREQAREQAREQAREQAREQAREQAREQAREQApQ3QMiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIdloAUoB320qpiIiACIiACIiACIiACIiACIiACIiACIiACIiACUoDqHhABERABERABERABERABERABERABERABERABEeiwBKQA7bCXVhUTAREQAREQAREQAREQAREQAREQAREQAREQARGQAlT3gAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQIclIAVoh720qpgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAUoLoHREAEREAEREAEREAEREAEREAEREAEREAEREAEOiwBKUA77KVVxURABERABERABERABERABERABERABERABERABKQA1T0gAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiLQYQlIAdphL60qJgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAWo7gEREAEREAEREAEREAEREAEREAEREAEREAEREIEOS0AK0A57aVUxERABERABERABERABERABERABERABERABERABKUB1D4iACIiACIiACIiACIiACIiACIiACIiACIiACHRYAlKAdthLq4qJgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAhIAap7QAREQAREQAREQAREQAREQAREQAREQAREQAREoMMSkAK0w15aVUwEREAEREAEREAEREAEREAEREAEREAEREAEREAKUN0DIiACIiACIiACIiACIiACIiACIiACIiACIiACHZZAlw5bs3ZQsU8//dTuvPPOqKTzzz+/rbjiii1X6okTJ9r48eOjcnXq1Mn4kzSegK5D45mHctR1CFFpTtivv/4aZdzW1madO3duTiGUq+k6tMZNoOug69AaBFqjFHy38r5GeD/wnpA0noCuQ+OZh3LUdQhRaXyYrkPjmYdynDBhgvGHSLcRItSYsGZeBylAG3ONg7m89dZbtssuu0TH2LaiAnTcuHH2/XffRWXs0aOH9erdO1gXBWZLQNchW76Vpq7rUCmp7ON9+803USadcp3bqaeeOvsMlUOQgK5DEEvDA/PXITdIOXWfPg3PXxn+RkDXoTXuhDE//GC8r5Gpcu8HDZI157roOjSHezxXXYc4kebs6zo0h3s8159//tl+HDMmCu7Vq5f16NkzHkX7DSDQzOsgc74GXGBlIQIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIi0BwCUoA2h7tyFQEREAEREAEREAEREAEREAEREAEREAEREAERaAABKUAbAFlZiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAINIeAFKDN4a5cRUAEREAEREAEREAEREAEREAEREAEREAEREAEGkBACtAGQFYWIiACIiACIiACIiACIiACIiACIiACIiACIiACzSEgBWhzuCtXERABERABERABERABERABERABERABERABERCBBhCQArQBkJWFCIiACIiACIiACIiACIiACIiACIiACIiACIhAcwhIAdoc7spVBERABERABERABERABERABERABERABERABESgAQSkAG0AZGUhAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiLQHAJSgDaHu3IVAREQAREQAREQAREQAREQAREQAREQAREQARFoAAEpQBsAWVmIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAg0h4AUoM3hrlxFQAREQAREQAREQAREQAREQAREQAREQAREQAQaQEAK0AZAVhYiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIALNISAFaHO4K1cREAEREAEREAEREAEREAEREAEREAEREAEREIEGEJACtAGQlYUIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEBzCEgB2hzuylUEREAEREAEREAEREAEREAEREAEREAEREAERKABBKQAbQBkZSECIiACIiACIiACIiACIiACIiACIiACIiACItAcAlKANoe7chUBERABERABERABERABERABERABERABERABEWgAASlAGwBZWYiACIiACIiACIiACIiACIiACIiACIiACIiACDSHQJfmZJt+rmPGjLGXX37ZXnrpJXvrrbesX79+NvPMM9vqq69us8wyS00Zjhs3zu69996y55LPoosuWjaeIoiACIiACIiACIiACIiACIiACIiACIiACEwaBN7+9C178s0RtvWq200aFW7hWnYIBehrr71mQ4YMsa+//roI9ZFHHhkdO+aYY6xbt25Fx0sFfPDBB7bzzjuXihId22CDDeycc84pG08RREAEREAEREAEREAEREAEREAEREAEREAEOj6Bfz57p+150S72088/2sz9ZrFVF1qj41e6jhpOGD/evsgZNPaebjrr1bdvHSmFT233CtBXX301UnB+88031rt3b1t66aVt4MCBNnLkSHv88cft119/tWuuuca6du1qxx57bJhCQuj7778fHenSpYv16tUrIZbZZJNNlnhMB0RABERABERABERABERABERABERABERABCYNAhMmTrATbjrGzr7rtHyFdzlve7vvmEes/zQD8mGt9uOX3Mzq0xZcyLrl9F/7vPpKKsWrNM1nL7/c7thjTxs35sco3zlWW9UGX3mFTTnTTKmUg0TavQJ02LBhhvJzhhlmsOHDh9tcc82Vh/Ptt9/aTjvtZI899phdnoOJNSfT1SsVLEARLDzPOOOM6Lf+iYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiECcwNc/jLadzt3OHn3toYJD3475xoaesYX984h/W89uPQuOtcIO1pc3Dt3Ovn7/A5tu/vlSKVKlab7zwAN283bb5yw/p7U1jjjcPnnhRXv5hhvsyr+ub3s8+4y1tbWlUp52vQgSCsoXXnghArH//vsXKD8JnHLKKQusPpkqX404C9A55pijmtMUVwREQAREQAREQAREQAREQAREQAREQAREYBIi8OoHL9uah61cpPx0CF7/8DXb55I93G7LbH8cPdquHTzEXr3p5tTKVE2aD598SpTvNnfeYSvndHubD7/OFttqK/vk+RfsjbvvTq1M7VoB+t577+VBLLnkkvnf/o+ZPHPZ//3vf/6hsr+dAnTOOecsG1cRREAEREAEREAEREAEREAEREAEREAEREAEJj0CNz0+3P5yzJr20Zcflqz8bU/eZBf933kl4zTy4Ku33GKnzje/vXbLrallW22anzz/vHXp0d1mXWqpfBlmX3ml6PdnrxROxR/9u6vKfMQqfrRrBeiMM85oBx10kB1yyCE2++yzB6vNyvBOBgwY4H5WtHVT4H0LUHyKSkRABERABERABERABERABERABERABERABCZtAvj7HHbV/rbHhTvb2F/GVgTj6OGHRSvDVxQ5w0i3776HXbPxpvbDqP/ZrMssbavnpp/XK9WmyTR5rEV79ulTkHWPqaaK9r/79LN8OHE/efHF/H61P9q1D1AWO+IvST799NNIQcpxfIMuv/zySVGLwseNG2effPKJderUyUaNGmUnnniivfHGG/bhhx/a9NNPb/PMM4/97W9/s9VWW63o3FoCfv75Z/smsIp9LWmlec7EiRPzyVFGuEgaT0DXofHMQznqOoSoNDeMl2Artp3NpdL43HUdGs88lOOECRP0PITANDhM16HBwGPZjc+9F5x8l1sPIC2/YS5NbSsjoOtQGaesY+k6ZE24svR1HSrjlHUs3s9OfvzxRxs7tjJlpTsnaXvIdQfazU9en3Q4GD5wpvlsqm5TNf277cNnnrHuU0xuS+22my2391722u9T4MfX8U1ZLs3Qdeg1zbT209ffFPD46qOPI3bdpp46H/7KdcOte/duQaaVBLZrBWiogqeeeqq9++67kbLynXfeMeAuscQSdtZZZ1nnzp1DpwTDUHS6CzNkyJCCOJ9//rnx98gjj9igQYOiBZK6d+9eEKfanYm5cvoNY7XnNyI+yp9WL2MjODQ7D12HZl+B3/LXdWiN60Ap1C61xrXQddB1aA0CrVEKPQ+tcR3ct3xrlGbSLYWuQ2tce10HXYfWINAapUirL3fhfedUpPxcuq2fvTHxW/vOxtnGyw6xQzc60rp16db0fsxiO+xgs636J+uRWz8H0zf0UpHkdmr9lqkmTXcd+s07r/03p19j8aPpF14oKsKHTzwRbTlGWcbnjPEeO+lkW+fkE38rYw3/O5wC9NFHH7XnnnuuAAXWmtNMM01BWLkd5/+TeKwwv1tOI44itU/OLPfVV1+10047zUaOHGl33nmnTTvttHbUUUeVS1LHRUAEREAEREAEREAEREAEREAEREAEREAE2jmBf754l531r9NL1qJbW2fbsG1mW9CmtMU797XpNtzKNllu85LnNPLgvBusH8wOxWStUkuay+asT1GA3rrFlrbU7rvZ5y+/Yq/nfJNOv+iiNseaa0RFeeWaa+27jz6yGRdZpNaiWYdTgO6555722WefRdPWn376aRsx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QKMJdPt9pcpfJxQ7eG90WZSfCIiACIiACIiACIiACDSbALOj8AHqZCbraYM79c+t+/6H/8l+U/TL7f2x3zbFlNZ1tTVy8987u9O0bTECHcYHaItxVXFEQAREQAREQAREQAREQAREQAREQAREQATaGYHX/vtKfvX3qdu62VY2wLrm1J++9M0pQJ205dak6brGWtbWvbsL0rYFCRRewRYsoIokAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAo0g8OJ7z0fZYPG5hfW33m1di7LtN8U0UVhb167WdfU1rW3yyYviKKC1CEgB2lrXQ6URAREQAREQAREQAREQAREQAREQAREQARFoEoEX3/1tAaTZrJdN39YzWIq+k+csQNvarEvO52db3z+sQYORFdgSBDQFviUug9mrH7xsg45Zq2xpunftblNONqVN3buPLTbnkvanBVez6aeeoex5oQgHX7mvPfTqA3bK0DNtxflXDkVpmbAbHx9u1zx0RVSes3a8wAZMN1vLlK2VCjJm7Bjr1aNX04p0yxM32pUPXBrlf+aO59ts081eVVk2OG4dGz9hvC07cHk7eJPDqzo368g//vyjDTl5A5s4cWJ0/525w/lZZ6n0UyTw5Xdf2nWPXGVvf/qWvfvZ29a5U2eba8Z5bN5Z5rfNVtrKevfsXTa3d3LnXfHAJfb2J2/ZN2O+tsVzbfAy8yxvK8y3svWZvE/Z80MRammHsyhHqGwKEwEREAEREAEREAEREIFJkcBLv1uADmgL9xEm79Hb0M10XWY56zTLrJMionZZZylAW+Syjf5htL34ypNVl4aHbr8NDq5aWXTPc3fZ2XefHuX33Y/fVp1vo094//N37cFX7o+y/X7s943OvuXz++GnH+z4m46yr77/0i7c7fKmlfe//3s/f51++Kn66/TAK/fZhAkTmqrETYL36/hf83Wb/9sFk6IpvMUIcD+deec/7JTbjrfvfvyuoHQMACEn33qcnbTt6bbhspsUHPd3Drn6ADsn12aioHcy4o3H7Ky7TosGoe487D6bL6dMrUZqaYezKEc1ZVZcERABERABERABERABEejIBL4d8419kOvXIjPnFj8KSb8pp7HOCyxkneYZGDqssBYlIAVoC16Y5QauYNNMOW2wZD+M/cE+/vJDe2/Uuzbu13H287if7bgbj8xZXrfZQRsfFjwnHvjY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AlSBQuBevny5saasrAx33XVXp16auPWJJ54wli9cuBApzB/RiVEiF9hyHcg/NxuzFmZgelEGJvTLxAx5nnlEJtIW9KxgVSKPi/smARIgARIgARIgARIgARIgARIgARIgARKIjMABLYBqePvixYuNx3333deO3OTJkzFt2jRj2W233YbVq1e3rdfE6hdddBE2btxoLLv44ovb1vGFdQjYvHaknZKFwd/LxZizs1EkzynHZ0IShLKRAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAkcIAQO6CowdXV1+Pzzzw1Tl5SUdDK5iqLqCfrFF1/g5JNPxtChQzF8+HBoWLxZHf6CCy7ArFmzOm3LBdYhYO8nf+b6YCMBEiABEiABEiABEiABEiABEiABEiABEjjgCNAXrguTFxQU4OGHH8akSZOMXlu2bMHKlSsN8VND3n/yk5/g2muv7WIEriIBEiABEiABEiABEiABEiABEiABEiABEiABEkgkgaR0i/vlL38JfXTXZsyY0a6Se7D+RUVFeOGFF7Bv3z689dZb2Lp1KwYNGgTN+5mTkxNsEy4jARIgARIgARIgARIgARIgARIgARIgARIgARKwCIGkFEDjwTY/Px/HH398PIbmmCRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAnEiwBD4OIHlsCRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAoknQAE08TbgDEiABEiABEiABEiABEiABEiABEiABEiABEiABOJEgAJonMByWBIgARIgARIgARIgARIgARIgARIgARIgARIggcQToACaeBtwBiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAnEiQAE0TmA5LAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQQOIJUABNvA04AxIgARIgARIgARIgARIgARIgARIgARIgARIggTgRoAAaJ7AclgRIgARIgARIgARIgARIgARIgARIgARIgARIIPEEKIAm3gacAQmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQQJwIUACNE1gOSwIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkkHgCFEATbwPOgARIgARIgARIgARIgARIgARIgARIgARIgARIIE4EKIDGCSyHJQESIAESIAESIAESIAESIAESIAESIAESIAESSDwBCqCJtwFnQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkECcCFEDjBJbDkgAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJJJ4ABdDE24AzIAESIAESIAESIAESIAESIAESIAESIAESIAESiBMBZ5zG5bAREli3bh1uvvnmCLeKf3efz4f6+npjRy6nE26PJ/475R46EaAdOiFJyALaISHYg+60urraWG6z2ZCamhq0DxfGnwDtEH/G4eyBdgiHUvz70A7xZxzOHupqa9HU3Gx0TUlJgd1Of49wuMW6D+0Qa6LRjUc7RMct1lvRDrEmGt14jY2NaGhoMDZ2u91wuVzRDcStekSgp3Y4+uijMXny5KjmQAE0Kmyx2UhPyDwiKOqH8K233jIesRmZo5AACZAACZAACZAACZAACZAACZAACZAACZBA8hDIycmJWgDlLdEE/h0sXrwYdXV1GD9+fAJnwV2TAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQQPISsPmlJe/h9Y0je+KJJ1BaWto3JstZkgAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkEAvE1i0aBHGjBkT1V4pgEaFjRuRAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAn0BQIMge8LVuIcSYAESIAESIAESIAESIAESIAESIAESIAESIAEoiJAATQqbNyIBEiABEiABEiABEiABEiABEiABEiABEiABEigLxCgANoXrMQ5kgAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJREWAAmhU2LgRCZAACZAACZAACZAACZAACZAACZAACZAACZBAXyBAAbQvWIlzJAESIAESIAESIAESIAESIAESIAESIAESIAESiIoABdCosHEjEiABEiABEiABEiABEiABEiABEiABEiABEiCBvkCAAmhfsBLnSAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkEBUBCqBRYeNGJEACJEACJEACJEACJEACJEACJEACJEACJEACfYEABdC+YCXOkQRIgARIgARIgARIgARIgARIgARIgARIgARIICoCFECjwsaNSIAESIAESIAESIAESIAESIAESIAESIAESIAE+gIBCqB9wUqcIwmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQQFQEKIBGhY0bkQAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJ9AUCFED7gpU4RxIgARIgARIgARIgARIgARIgARIgARIgARIggagIUACNChs3IgESIAESIAESIAESIAESIAESIAESIAESIAES6AsEKID2BStxjiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAlERoAAaFTZuRAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIk0BcIUADtC1biHEmABEiABEiABEiABEiABEiABEiABEiABEiABKIiQAE0KmzciARIgARIgARIgARIgARIgARIgARIgARIgARIoC8QoADaF6zEOZIACZAACZAACZAACZAACZAACZAACZAACZAACURFwBnVVtwoqQlUVVXh5ZdfxtatW7Fv3z7s3bsXjY2NyM3NRV5eHvr164f58+dj5MiRSc2BB3dgE/D5fHjmmWewbt067Ny5E2PGjMGCBQswd+7cLsHcfffd+Pjjj7FkyRLj0WVnruwxgfLycjz66KPYuHEjPB4PJkyYYNhoxIgRPR6bA0RGYM+ePcZnJCMjA2vXro1sY/buMQH97X7xxRfx0UcfYdeuXdDPwLhx43DkkUfC7Xb3eHwO0J7AZ599htLSUsyePbvdiu3bt+Nf//oXNm3ahK+//hpDhgzB2LFjsXz5chQUFLTryzfREXj++efxgx/8ACkpKbj99tuxePHi6AbiVjEn4Pf7YbPZOo27fv1649riyy+/xMCBA43fav1u8nq9nfpyQc8JbNu2DWvWrDGu4/R7qrm52biO02s5/U6aNm0anE7KAD0n3fUI+nv87rvvGnbQa+qSkhKkpaW1XVOb1xb6XcZGAslKwGrX1Db5ofInK2weV2QENmzYgNtuuw0rVqxAfX19txvrxdVJJ52Eiy66yDgJ7XYDdiCBPkJARc8f//jH+PTTTzvN+LTTTsP111+P9PT0Tut0wbe+9S288soruOyyy4wxgnbiwrAJ3H///fjvf/9r2EJPGufMmWNw1QsovUlz9NFHQ0XQwKYn9cr/kksugcPhCFzF13EksHv3bkyfPt34bKggzRY7Ar/61a8MUfOUU07BIYcc0mng9957DxdffLEhuHVcOWzYMPzP//wPb8h0BBPl+w8++ABXX321IS7oTbFHHnmkbaR//vOfuOKKK1BZWdm2zHyhvxn6u3L++efDbmcAlsklmmcVmC+88EJjU/2O//nPf47vfe97QYW3aMbnNpER+OKLL4zzIhV6amtrjRvG3//+97F06VJjoF/+8pe499570fGSU68jfve733W6iRDZ3tnbJKAi59/+9jf86U9/wueff24uDvqs51PqzKK/KWqnYKJ10A25sFsCaoc777zTuDm/efPmbvvrTYCFCxcav+GzZs3qtj87kEBfImDFa2re+ulLf0FxnKuetJx11lmdTtr1BzI7O9vwrNI7iCo06Be7Nj3hueWWW4yT/wcffNDwNInjFDk0CfQKAb07e/bZZxt3a3WHelKod8yLi4uN/au3oXpF6988L2LjZxL9nlGh4IUXXmi3E/3eWbVqleHppiKnKX6q6KnfVXqHXe80/va3vzXspMIRW3QE9EK2u4uowJHNz0hTUxPU2yewaeRA//79AxfxdQQEXnrpJajHoXrtdBRA1eN82bJlxt+9DqnfWUVFRcZnoa6uDl999ZXxWbrjjjuMfhHsll07ENCbLnoTTL1ttQWKBvq9pDddzKY2UIGnrKzMsJ1uo0JQdXU1fvSjH5nd+NxDAioe/PrXvzZ+F/SZ0Uk9BBrh5m+++SbOOecc4+/a3PTDDz/EBRdcgD/+8Y/G99L//d//mauMKDJ1stDfbv09P/XUU6EevePHj2/rwxeRE9DvlzPOOKPL6AuNztDfBI3q0+8hvbmsj0mTJhme1OqpztYzAnr++cMf/hBPPfVUu4H0HDUrK8t4qA30mlrPsbTpe43e0Id+bq699lpjOf8jgb5OwKrX1BRA+/pfVgzmr6GK3/zmN40vYg3P0hOZefPmYerUqZ3C5vTubUVFheH5oJ4Ozz33HDTcS390VahgeFcMDMIhEkrgmmuuMYQDDRn92c9+ZoihGpqiwppeXKkAqh6e99xzj+FxktDJJvHOn3766TbxUy9oDzvsMENIUJFBv3PUY0GFHbWNepBoygG1mYb+qgeWntQ/8MADxneThsWzRU5Axc9jjjkm4g31pL7jdvSIjhhjWBvojQL9ntKLLhWC1DNRBTr9XOjvtYoT6rGugrR+LmbOnInBgweHNTY7dSZw+eWXG+JnZmamwVOjYLSp6H/VVVcZrwcMGIBbb70VixYtMt7rf3qxqzeM//KXvxjP6jlKT582PD168eyzzxq/xa+99prxO6E3MPX7Rm+IscWXQENDA/QzoWKaCjwnn3yycaNr5cqVUBH0Jz/5CVwulzEJ/U343//9X0MA1QW6Xm8YqIec9lOvXt5Ujt5eGo1npp5Rr05NC1FYWGicE2mEgEbT6A0b5ay20qi///znP8Z5loZpq+3+8Y9/YPLkydFPglsanul6bazNTIWlqbPUFh2b3gjQ81nt/8QTTxipnNRTWoVS3iTrSIvv+yIBq15TMwS+L/41xXjOevKiIRN6Mq5fvJGImJpfRsXTmpoa40RGL7DYIiegP4LqURiLpiGoM2bMiMVQB+QYBx10kCF26udC7+J2bL/4xS8MYS01NRWvvvpqp5MahsB3JBbd+6OOOso4QVfB5uGHH25Ls6HetyeeeCK2bNliDKw/rt/5znfa7URFIT3x1JP6b3zjG4bg0K4D34RFQMPYVXiORaMA2jOK6vWpHqDXXXcdzjvvvLbB9ML2+OOPN96rl9Wxxx7bts58oZ5BesNAhQYNE9ZweLbICaigPGrUKMNbR2+uHHHEEW2DfPLJJ23v1ZstlIigeSv1QlfPm26++ea27fkiMgKBIfCaU1IFaP1t1huU2lT81O+cb3/7220CXGR7YO9wCKgjhIqYKlzq37WZD1d/gzXdg2kPzUWs3m0dBU7Nk3v44YcbkWXqRKGeiGyRE1AxWc95tGkeevM3IXCkt99+u02gVsFNozK06e+8nuvqTbIpU6YYYlzgdnwdPgEzDZD+nesNL/VuDrfpd5iK2HpDR29gamRmTk5OuJuzXwABXlMHwEjwS6teU9MDNMF/GFbYvf4oatO7TZGIn7qNihO6nXrG6Uk/BVClEnlTj6lYhTzoST8F0MhtoFtoSJZ6empTr+ZgTQU39TTR0C0Nr9Y8P2yxJaBCg14YaVOhQE8GzabfURoiZIo46rXQsenJ53e/+11oDrJIQrg7jnOgv9dwuIceegiXXnqpkQJCPdv0uz6UB6GGwKu99OZAx9QFPJGPz1+TmadYvZyDiZ+6V809qb8LmiNURVS26Ajs2LHDED/1+6jjjQEz561+NkKJn7pX9cxSoUgFU7bYEVCbqNeteuSqR7SmKlBvaI3UOP30040bYZqSgC22BMy/e/XuNMVP3YP+Buu5kimAqlduR/FT+2kBGL1pr84U+ltNAVSpRN5UXNam0XvBxE9dp/nTNVXKk08+aUQx6c1hbfo7f9999xnF8lRI1WtC7csWOQHzelpT1UQifuqeNJexpqlRxwrNIa3XGSeccELkk+AWRkQrr6kT/4dg5WtqZmFP/N9HQmegYVmmQBB48hLJpMyq2FpxkC06AnryrsKBhtWxJY6AVrHWpuFBeXl5QSeilcZvuOEGY52Gab///vtB+3Fh9AQ0jF1zVGnTIkcdm3mRpEJbKDuNHj3a2EyFarboCajQo4XxNJxO7aKeIireTJw4sdPDzB+mF7qa+zDwQQE0eht0taX5u9uV6Kbbm2kgKIB2RbPrdWZhI001EJj7M3Arra7cVTNFOPVaZIs9Af2e0hQ1etNGz6c0vFRTpKigozc1n3nmmXa5KmM/gwNrxK+//to4YPXw7NjUC1eLFWrT34JQzfzM8DMRilD3y/XvXJumLuuqmdd5KnQGNrXTkUceaSwyb6oFrufr8Aio16Y2k3N4W+3vpeki1LFIm/nbvn8tX4VLgNfU4ZKKbz8rX1PTAzS+trf86CrmmE2F0O4uosy+gc+mwBDKKyiwL18HJ6B20HA4vWOlhV/0zp+2u+66C4dI6GMkLdCmkWzHvsAwqZaseSQ1r5V6IAY7qVdOWq1RPR7U61m9Tf79738zzC6Gf0AqMJhNk8N3bOqJqK0rUc3cTnMjsvWMgHrdapoUDbHWHG4qgqooeuONNxq5qno2OrfuCYHhw4cbm+vNzK6aWWzBLN7TVV+uC05g6NChxgplrTcBTFFZF5rCg+Yl7qqZN5zNsbrqy3XREdCL35/+9KdGugdNLaSpnfRCTD2r9KGeVhqWp0KDeh+G8piLbu8H1lbmb3Cw7xWNptGbZtrMYoXB6JgXyaFuZgbbhsvaE9CCtdo0HVlXzbyxbEY6BfYdNGiQ8VbrPLBFR0CvH7SZ3/PRjMJr6miotd+G19TteSTqnZWvqekBmqi/CovsVz2oTI8EzWmloaeRNM3z89hjjxmbaOgFW88IaKiieiuYTU/k1YshkgcFUJNe5M9691U927RpHp6umobXKWtNJH/77bd31ZXrIiSgF1X6w6lNcxx2bHqhpMn6//CHP3Rc1fZeK2NrMz1B21bwRVQE1ONN0wpo7j0tSqWeVJoDUYvssCWOgCnCaQhpV830VDcF0676cl1wAvp7bHrnaH7DQFFHv6/0oZ5YHdM/mKPp+ZJZDVsFOLb4EtDzKc2pt3r1avz2t7+F+bevufb0d0VtceGFF8Z3Ekk+uubE1aY37ZVrYNPPgXlN8frrrweuanutXtWaq1ubaZ+2lXwRNgHzd0A5myJnsI3XrVtnLNbUAx2b+Ruh32Ns0REwub7xxhtRpZvR7yozv70ZXRndTLiVEuA1dWL/Dqx8TU0BNLF/G5bYu+bT06aCghYTCffOlXpA6J1z01tRQ4/Yek5ABWkzxLfno3GESAmYuY80n9htt91mVO8NNoZ68KgIqk2TnWuuMbbYETA9qq688kp0DI3TGzdaYdm0Vce9aqEkMzcrBdCOdHr2XqME1PNZ8+ppTkStOK55Qbu66OrZHrl1IAEtCKaFkNQjVy+WtJCFVhQvKSlpd/MscBsNpdPvKG2hPjOB/fk6NIGf//znxkoNIdVibI8//riRF1QX6k1krd6r4qhZBdgcST8regNBbaY3zs455xxzFZ/jTEB5n3nmmVBxSMPjf/nLXxo3b0yvuTjvPqmH1xQpylevB84991wjMkC9zVetWoWbbrqp7dj/+te/Gt63bQvkhUbaaN2AsrIyo2iV+Zsf2IevwyOgef/1JqVev1111VXQIjAdm+YJ1fzD2jqy1rygK1euNNaFinwyVvK/Lglozk79TVZPXL0+fuqpp4x8lF1uJCs1UkkdKczaA3oNmJ+f391mXB8GAV5ThwEpjl3Mc06rXVOzCnwcjd5XhtYfSq0qqyeGZtM7sfpHq1/AmsdHT+q1n4ZG7Ny500hYrnlizLu7Wn1TCyywxYaAstQfzvvvv78tL09sRuYo3RHQ0GlN2B/osaDpHfRvPFhCck1ZYF7sagVN9QrSO7iset0d6a7XqwenimsabqoXWMr24IMPhilAdNxaL6b0O0m9GP70pz8ZRao0HEnTE5jeER234fueEVAvaQ011d8FPWHXCy8trKB33c3iGD3bA7c2CWgqlFD5OzVnsZnqQX83Zs2aZWymRam0qIJWatabAnrjQAU4hpqaVKN71qgXFTlNjzc9R9IbA5rLUKsAv/TSS8bA6smu3tIqTutvgtlfi+epWMQWPYGOVeDN0NNIRtTPjP5emJ+XSLZl3/0E9OZKYOTS/jUwKryrt7N5A0ZTB+lnRT0///vf/xq/09pfb3Sqty5b9ATUBiZnPWfV/Ol6o14F5rVr17YJnCpaa3FDbeqlq9uYXrhaROyPf/xj9JPglgZnvaY20zDp+ev8+fMND2f9TdDfC/2+0s+AXi9oFJnaR+2kTfPl6o1OMzqTSHtOgNfUPWcY7QhWvaamABqtRZNsO/Xe+c1vfmNUAjS/tMM5RM3Vp15wKhixxY6AVhLUUBU9WWSusNhxDXck9WDQC1TTu1m3U0+FSy65pNMQKrzpBe2f//zndusogLbDEdUbPSlXEdQMNdVwiq9C5NjT5PN68h7YtAqterWzxY+Ahvzq5+Kdd94xcuupyEMBNPa8VczU3GDqDa2fAX02X5vFeXSvjzzyiOERqq81PYFZiVZ/q3//+9/juOOO01VsPSSgwpkKBy+//HLYI2mOvcsvvxwnn3xy2NuwY3ACsRBAg4/MpZES0NQOd999t5FmIDASYPz48dAcrJqzWz1w1Ss0WDvqqKOMfPeBub+D9eOyrgmoHfSGpIpnoZreqFSb9O/f3+iitQfUM0ubVi7XavCa85utZwRU0FRRf/369RENRBtEhCvszrymDhtVXDpa8ZqaAmhcTN13B9XE2BoK8dZbb0EFhY6FFTR5vP44ap6TZcuWYenSpcbFbt89Ys6cBEIT0DuzGjakIs+hhx5q/L2H6q0nOuo1qkKQfnZUQFUvIbaeEVCPqkcffRSaU0m/n0zvqo6jBgqgepKvN2b0rjtb/Amo6Kniml5I6UUYBdD4Mw/cg3oYmoKoFmgzL25VAFVPFPWc/sEPfmBc4AZux9c9J6Ahp8pZL7DUQ1e9ePSGjQpBWllZvXhU+NSQU00bEY2nYs9nmXwjUAC1nk31t1pzq27dutXwYtO0WHrTUpt+R2kBPb2+UCcL9VofO3ascR2heVg1fJstNgQ0PYd6cWoUjd4s0wg+TQWkEUzf/va3jRuV5p40lYp+f2m+yW9+85vt1pl9+Bw9AS26puesGnmhUTFmFIA5YkZGhvF7rV65y5cvj6oQsTkWn0nA6gSsdE1NAdTqfy0Jnp96t+nJvHqYqNu+uu/zRCXBRuHuLU9AU0NUV1fz5kAvWkovsPQEU0NONQcTW+8T0JMbDfXVi1v16mFLLAH9/VZb2O1M955YS3DvsSagv7Fm2gdTZIv1Pjhe7Amo3TQdhxkGHPs9cMRAAiq4qeMKW+IJ6N++Gfaus1FnIno9J94unIH1CcTjmpoCqPXtzhmSAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAlEScAZ5XbcjARIgARIgARIgARIgARIgARIgARIgARIoJWApkfRAqmffPKJUYBQUzNp6jhNSRCqaQSNWVBMq8Kz9ZyARgo888wzRl0NLeKsKfwWLFhgpH3oanTNa6xpJJYsWWI8uurLdd0TsJod6AHavc3YgwRIgARIgARIgARIgARIgARIgARIgASCElCh58Ybb8S9997blqbD7Kj5ubV43iGHHGIuavesxfXMQoVae4CtZwS0mLDWYvj00087DaQFVq+//vqQqcq+9a1v4ZVXXgEL2nZCF/ECK9qBiaEiNiM3IAESIAESIAESIAESIAESIAESIAESIIEWAnfccQfuuuuuNvFTi0KauT61UNjZZ59tFEUir/gS0LoAytoUP7V+SV5eXttOtbiqFmDTwp1s8SNgVTtQAI2fzTkyCZAACZAACZAACZAACZAACZAACZBAEhPQsPdbb73VOMLp06fjxRdfNIpzbtq0Cffff79R8V09RC+66CKjIFISo0j4oV1zzTXYt28f3G43rrrqKnz22Wf48MMP8cEHH0C9P7Wph+c999yT8Lkm8wSsagfmAE3mv7owjq2+vh4PPvhgGD2776Jf9jNmzOi+I3t0IkA7dEKSkAW0Q0Kwd9op7dAJSUIW0A4Jwd5pp7RDJyQJWUA7JAR70J2+9dZb+Oijj4Kui3ThBRdcEOkm7N9KgHawxp8C7WANO7z55puG56d6Gj700EPIzs42JuZwOHDkkUdi5MiROPbYY6GeoDfddBOuu+46a0w8CWexatUq46guvfRSw9PTPMT8/HxDpE5JScEDDzxgpCQ48cQTUVhYaHbhcwwJWNUOFEBjaOS+OFRtbS2uvfbamExd82RQAI0OJe0QHbdYb0U7xJpodOPRDtFxi/VWtEOsiUY3Hu0QHbdYb0U7xJpo9OP95z//wV/+8pfoBwjYkgJoAIwIX9IOEQKLU3faIU5gIxxWPUC1LV26tE38DBxixIgRUI84zUt53333QfNMalEettgSKC8vN7w/ddQzzjgj6OBqh9deew1ffPEFfvWrX+HOO+8M2o8LoydgZTswBD56uybFlnoH5Jvf/CYyMzOT4nj66kHQDtawHO1AO1iDgDVmwc8D7WANAtaYBT8P1rCDzuLQQw/FtGnTrDOhA3QmtIM1DE87WMMOe/bsMSYyYMCAkBM6/fTTMXv2bCP3pBbhYYs9AdMOTqezXd7PwD15PB7ccMMNxqKnn34aWoCKLbYErGwHVoGPra377GhVVVU4//zzjbshehCawDlUlbpQB6lfJvpgi54A7RA9u1huSTvEkmb0Y9EO0bOL5Za0QyxpRj8W7RA9u1huSTvEkmbPxnr++eeNfHqanmDixIl4/PHHIx6QDgARI+u0Ae3QCUlCFtAOCcHetlPN/3nzzTcbHqBaBT5U0/QdxxxzDPx+v5GD0qz8zirwoYhFtryxsdHwrG1oaMCKFSswbty4kAOcd9550M+N/n78+9//hsvlMvqyCnxIZGGvsLIdGAIfthmTu6NWqfvd735n3JXSI1VPB54U9r7NaYfeZx5sj7RDMCq9v4x26H3mwfZIOwSj0vvLaIfeZx5sj7RDMCqJWaYiwrJly/Dwww/DbrfzvDUxZjDEHNohQfADdsvPQwCMBLycOnWqsdfVq1dj7969KCgoCDqLSZMmGaHZf/vb33DFFVdg7ty5IT0Vgw7AhV0SUBFTBU0VlJ999tkuBdCrr77aKIa0YcMG3H777UZ6gi4H58qwCVjZDgyBD9uMyd+xqKgI+qXMllgCtENi+Zt7px1MEol9ph0Sy9/cO+1gkkjsM+2QWP7m3mkHk0Tin4866qjET4IzAO1gjT8C2iFxdjjooIOMSMiSkhIsX74c69evR1NTU9AJqfA2dOhQaN9TTz0VO3bsCNqPC6MjMGfOHGND9cq97bbbUFpaGnQgtYHaQtstt9zCqvBBKUW/0Kp2oAAavU2TcstRo0Yl5XH1tYOiHaxhMdqBdrAGAWvMgp8H2sEaBKwxC34erGGH0aNHW2MiB/gsaAdr/AHQDomzQ25uLjT0XT3ftLiOeuSOHTvWEDg7zkojCTTdnPbduHEjFi9ebFQn79iP76Mj8NOf/hQLFiwwNr7pppsMB6+DDz4YzzzzTKcBzznnHCxZssRYft111xmv1X5sPSdgVTs4pAL4tT0/PI6QLATy8/ONL2tV7LOzs5PlsPrccdAO1jAZ7UA7WIOANWbBzwPtYA0C1pgFPw/WsIOma8rIyMCiRYswfvx4a0zqAJwF7WANo9MOibWDVnrXyu4vvfQSfD6f8di9ezcuvfTSThPTYkkqfK5atQrFxcX48ssv2/popXi26AloASTNraph8F9//bUxUEVFBaZMmdKW7i9wdBWrNb+39ld7aQVzbZqeYN68eYFd+ToCAla1A4sgRWBEdiUBEiABEiABEiABEiABEiABEiABEiCBYARqamrw3HPPQXNLaj7QP/zhD8G6GcsqKyuxcuVKvP3223jnnXfw8ccfY9u2bSH7c0VkBNQGL774IrZv345DDz3UKFIVagRNW/D6668bdnj33Xdx7rnnMi9oKFgRLreSHSiARmg8dicBEiABEiABEiABEiABEiABEiABEiCBWBJQQVS92tkSS8Dv96O6uhqaroAtcQTiYQcKoImzJ/dMAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiQQZwLOOI/P4fsgAc2B8fLLL2Pr1q3Yt2+f4brf2NgITe6cl5eHfv36Yf78+Rg5cmQfPLq+M2XawRq2oh1oB2sQsMYs+HmgHaxBwBqz4OfBGnbQWXz00UfQkEU9b9WHVldOS0trO3fVvHxaFCMlJcU6k07CmdAO1jAq7UA7WIOANWbB32raIZAABdBAGgf4a83NcNttt2HFihWor6/vloYmej7ppJNw0UUX8YSyW1rhd6AdwmcVz560Qzzphj827RA+q3j2pB3iSTf8sWmH8FnFsyftEE+64Y/d3NyMO++8E48++ig2b97c7YZerxcLFy7ExRdfjFmzZnXbnx3CI0A7hMcp3r1oh3gTDm982iE8Tr3Ri7/VvUG5+31YzQ4Mge/eZgdED71rftZZZ0HzjgQ2vY13lIYAAEAASURBVHuu1eA9Hg9KS0uNqmj6xR7YioqK8OCDD2LcuHGBi/k6CgK0QxTQ4rAJ7RAHqFEMSTtEAS0Om9AOcYAaxZC0QxTQ4rAJ7RAHqFEMqRWWf/jDH+Kpp55qt7VWnc3KyjIedXV1xrlrbW1tuz765oILLsC1117baTkXREaAdoiMV7x60w7xIhvZuLRDZLzi2Zu/1fGkG/7YVrQDBdDw7Ze0PdeuXYtvfOMb0BPEgoICnHPOOZg3bx6mTp0Kt9vd7rg1EW1FRQXWrFmDf/7zn0aFOz3B7N+/P1544QVj+3Yb8E3YBGiHsFHFtSPtEFe8YQ9OO4SNKq4daYe44g17cNohbFRx7Ug7xBVvRIOff/75xjmobrRkyRLjMXfuXBQWFnYaR6OatAKwVmV+4oknsHHjRqPPT37yE/zoRz/q1J8LwidAO4TPKp49aYd40g1/bNohfFbx7Mnf6njSDX9sy9pBBC22A5zAT3/6U7+cMPpPPPFE/549eyKiIaq+f9SoUcb2N9xwQ0TbsnN7ArRDex6Jekc7JIp8+/3SDu15JOod7ZAo8u33Szu055God7RDosi33++uXbuM885Bgwb5Jfy9/cpu3omHlv873/mOsb3ksvdLrtButuDqUARoh1Bkenc57dC7vEPtjXYIRab3l/O3uveZB9ujVe1gD1/DZc9kJfD2228bh6Z3wdUDNJI2c+bMtrvnzz//fCSbsm8HArRDByAJeks7JAh8h93SDh2AJOgt7ZAg8B12Szt0AJKgt7RDgsB32K1ph2nTpuHUU0/tsLbrtw6HA3fccQcyMjKMyKfXXnut6w24NiQB2iEkml5dQTv0Ku6QO6MdQqLp9RWmLaht9Dr6dju0qh0ogLYz04H3RvN6fv7558aBz549OyoAGnKkbdu2bVFtz41g5KiiHRL/l8DPQ+JtoDOgHWgHaxCwxiz4eaAdrEHAOrPQnGLaoj1vdblc0Bv42njuamCI6j/aISpsMd+Idog50qgGpB2iwhbzjXjOFHOkUQ1oZTtQAI3KpMmzkRY3MpspwJnvw33+4osvjK6DBw8OdxP260CAdugAJEFvaYcEge+wW9qhA5AEvaUdEgS+w25phw5AEvSWdkgQ+CC7NfPTR3veqkPy3DUI2AgX0Q4RAotTd9ohTmAjHJZ2iBBYnLrztzpOYCMc1sp2oAAaoTGTrXtqaiq0iru2Bx54AJK/IaJD1Irwjz32mLGNFk5ii44A7RAdt1hvRTvEmmh049EO0XGL9Va0Q6yJRjce7RAdt1hvRTvEmmj0440ZM8bY+I033sBnn30W8UCrV6/Gli1bjO3MKKaIB+EGoB2s8UdAO9AO1iBgjVnwt5p26I4ABdDuCB0A6y+44ALjKP/xj39AEsO3hcR3d+iffPIJjj/+eJj5kxYvXtzdJlzfBQHaoQs4vbiKduhF2F3sinboAk4vrqIdehF2F7uiHbqA04uraIdehN3Frk444QT069cPNTU1xnnoU089ZeTz7GITY5UUQMLtt9+OM844w3g/adIk5Ofnd7cZ14cgQDuEANPLi2mHXgYeYne0QwgwCVjM3+oEQA+yS6vawaYVm4LMl4sOIAL19fU477zz8Morr7Qd9fDhwzFnzhzjxDA7OxtZWVnQfhUVFdi5cyfWrFmDTz/9tM1j9Be/+AUuvvjitu35InICtEPkzOKxBe0QD6qRj0k7RM4sHlvQDvGgGvmYtEPkzOKxBe0QD6rRjbly5Urj3LWurs4YQMPt5s+fDz1/zcnJgZ67akhqZWUlysvLsWHDBqxduxZlZWVG/xEjRuDhhx9ui4KKbhbcinawxt8A7UA7WIOANWbB32raoSsCFEC7onMArWtsbMRvfvMb3HfffTBPJsM5fK/Xi6uvvhpnn312ON3ZpxsCtEM3gHppNe3QS6C72Q3t0A2gXlpNO/QS6G52Qzt0A6iXVtMOvQQ6jN2ooHnllVdi/fr1YfTe30Wrx+v5bkFBwf6FfBU1AdohanQx3ZB2iCnOqAejHaJGF9MN+VsdU5xRD2ZFO1AAjdqcybnhvn378OSTT+Ktt96CVrPTCl6BzeFwGCeMmm9m2bJlWLp0KdLT0wO78HUMCNAOMYAYgyFohxhAjMEQtEMMIMZgCNohBhBjMATtEAOIMRiCdogBxBgN8eqrr+Kll16C5vbcuHEjmpqa2o2ckZGB/v3747DDDsPy5csxefLkduv5JjYEaIfYcOzpKLRDTwnGZnvaITYcezoKf6t7SjA221vJDhRAY2PTpB2loaHBCB3SECINJ9KwIpvNlrTHa9UDox2sYRnagXawBgFrzIKfB9rBGgSsMQt+HqxhB83sZYa964zUy1Ojldh6lwDt0Lu8Q+2NdghFpneX0w69y7urvfG3uis6vbcukXagANp7drb8njQ5/DPPPIN169YZeT7Vy3PBggXorkLm3XffjY8//hhLliwxHpY/UItPkHawhoFoB9rBGgSsMQt+HmgHaxCwxiz4ebCGHXQWn3/+OZ577jloYU6t/quFjTRCSXPXh2paAf53v/udsVqLIrH1nADt0HOGsRiBdogFxZ6PQTv0nGEsRuBvdSwo9nwMy9lB7kiwkYD//fff90tokL+wsLDT49JLL/XL3fSQlM4880xjm5tvvjlkH64IjwDtEB6nePeiHeJNOLzxaYfwOMW7F+0Qb8LhjU87hMcp3r1oh3gTDm98ySvmv/766/1DhgzpdN4qOT79Utgz5EDvvfde2zYhO3FFWARoh7Awxb0T7RB3xGHtgHYIC1OvdOJvda9g7nYnVrSDveeaLkfo6wRKSkqMIkZa1V2bhrjn5eW1Hdajjz6KCy+8EM3NzW3L+CL2BGiH2DONZkTaIRpqsd+Gdog902hGpB2ioRb7bWiH2DONZkTaIRpq8dnmjjvuwF133QX1LNGm+ejNUPfdu3cb57WaE5QtvgRoh/jyDXd02iFcUvHtRzvEl2+4o/O3OlxS8e1nVTtQAI2v3fvE6Ndccw00Ma3b7cZVV12Fzz77DB9++CE++OADnHbaacYxyJ103HPPPX3iePrqJGkHa1iOdqAdrEHAGrPg54F2sAYBa8yCnwdr2EHDS2+99VZjMtOnT8eLL75oFD/atGkT7r//fqPgkQqjF110kZEP1BqzTr5Z0A7WsCntQDtYg4B1ZsHfamvYwqp2oABqjb+PhM5i1apVxv4l1N3w9ExJSTHe5+fnGyeYZ599tvH+lltuwY4dOxI612TeOe1gDevSDrSDNQhYYxb8PNAO1iBgjVnw82ANO7z55puG56dGKz300EOYMGGCMTGHw4EjjzwSjz/+ODIzM6GeoDfddJM1Jp2Es6AdrGFU2oF2sAYB68yCv9XWsIVV7UAB1Bp/HwmbRXl5ueH9qRM444wzgs5D1fsRI0agpqYGv/rVr4L24cKeEaAdesYvVlvTDrEi2bNxaIee8YvV1rRDrEj2bBzaoWf8YrU17RArkj0fRz3etC1duhTZ2dmdBtRzVj131XbfffdBPUPZYk+Adog902hGpB2ioRb7bWiH2DONZkT+VkdDLfbbWNkOFEBjb+8+NeKePXuM+TqdznZ5PwMPwuPx4IYbbjAWPf3005BktoGr+ToGBGiHGECMwRC0QwwgxmAI2iEGEGMwBO0QA4gxGIJ2iAHEGAxBO8QAYoyGMG0xYMCAkCOefvrpmD17tpG/XoolhezHFdEToB2iZxfLLWmHWNKMfizaIXp2sdzStAO1jVhSjXwsK9uBAmjk9kyqLYYNG2bk/tRcSV3dIV+4cCGOOeYY49h/9rOfQarcJRWHRB8M7ZBoC7Tsn3agHaxBwBqz4OeBdrAGAWvMgp8Ha9hBZzF27FhjMhs2bOhyUip8amHPl19+Gc8++2yXfbkycgK0Q+TM4rEF7RAPqpGPSTtEziweW/C3Oh5UIx/TynagABq5PZNqC5fLhYkTJxrH1N3J4dVXXw31BtUTzttvvz2pOCT6YGiHRFugZf+0A+1gDQLWmAU/D7SDNQhYYxb8PFjDDjqLqVOnGpPRKu979+4NObFJkya1pXe64oorUFxcHLIvV0ROgHaInFk8tqAd4kE18jFph8iZxWML/lbHg2rkY1rZDhRAI7dn0m0xZ84c45i0ouZtt92G0tLSoMc4dOhQqAiqTQsisSp8UExRL6QdokYX0w1ph5jijHow2iFqdDHdkHaIKc6oB6MdokYX0w1ph5jijHqwgw46yLghX1JSguXLl2P9+vVoamoKOp6et+r5q/Y99dRTWcwzKKXoFtIO0XGL9Va0Q6yJRjce7RAdt3hsxd/qeFCNfEzL2sHPdsATqK2t9Z922mn+wsLCtof8wfol32dQNuedd15bPwmL98+dO9d4f/PNNwftz4XhEaAdwuMU7160Q7wJhzc+7RAep3j3oh3iTTi88WmH8DjFuxftEG/C4Y//0ksv+UXYbDsfHTlypP+UU04JOsC6deva+o4aNcp/1llntW0XdAMuDJsA7RA2qrh2pB3iijfswWmHsFHFtSN/q+OKN+zBrWoHeoBGLmYn3RZerxf3338/NM+n2bZu3Yqvv/7afNvu+c4774SIoMayDz/8EFu2bGm3nm+iI0A7RMct1lvRDrEmGt14tEN03GK9Fe0Qa6LRjUc7RMct1lvRDrEmGv14hx9+OPR8NCUlxRhELrSwZs2aoAOqZ9Y///lPDBo0CDU1NVixYkXQflwYOQHaIXJm8diCdogH1cjHpB0iZxaPLfhbHQ+qkY9pVTs4rpUW+eFwi2QjoHka5M65UehIq2pq4trp06dj9OjRnQ7V4XDg0EMPxVFHHWX00z9uDS2aNm0a5s2b16k/F4RPgHYIn1U8e9IO8aQb/ti0Q/is4tmTdogn3fDHph3CZxXPnrRDPOlGNraeo55//vnGueqQIUMMgXPp0qVBBxk4cCC0MrzmBS0oKDCKee7btw+XXXZZ0P5cGD4B2iF8VvHsSTvEk274Y9MO4bOKZ0/+VseTbvhjW9EONvVhDf8Q2JMEghPQP6Pq6mqkp6cH78ClvUKAdugVzN3uhHboFlGvdKAdegVztzuhHbpF1CsdaIdewdztTmiHbhH1WofKykpkZGT02v64o+AEaIfgXHp7Ke3Q28SD7492CM6lt5fyt7q3iQffXzzsQAE0OGsuJQESIAESIAESIAESIAESIAESIAESIAESIAESSAICzAGaBEbkIZAACZAACZAACZAACZAACZAACZAACZAACZAACQQnQAE0OBcuJQESIAESIAESIAESIAESIAESIAESIAESIAESSAICFECTwIg8BBIgARIgARIgARIgARIgARIgARIgARIgARIggeAEKIAG58KlJEACJEACJEACJEACJEACJEACJEACJEACJEACSUCAAmgSGJGHQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkEJwABdDgXLiUBEiABEiABEiABEiABEiABEiABEiABEiABEggCQhQAE0CI/IQSIAESIAESIAESIAESIAE/r+9O4G7bSofOL6uOQ0iUbnlyhWuhGSuhFtJ0aCiUMaE6l5ThjKVZCjRoAGZaRAlmqSu0iwlIpWKJBVKhtJF//tb/ddrvfvdZ97vefe739/6fO49593nnD189z7r7P3sZ62lgAIKKKCAAgooUC5gALTcxakKKKCAAgoooIACCiiggAIKKKCAAgoo0AABA6AN2IluggIKKKCAAgoooIACCiiggAIKKKCAAgqUCxgALXdxqgIKKKCAAgoooIACCiiggAIKKKCAAgo0QMAAaAN2opuggAIKKKCAAgoooIACCiiggAIKKKCAAuUCBkDLXZyqgAIKKKCAAgoooIACCiiggAIKKKCAAg0QMADagJ3oJiiggAIKKKCAAgoooIACCiiggAIKKKBAuYAB0HIXpyqggAIKKKCAAgoooIACCiiggAIKKKBAAwQMgDZgJ7oJCiiggAIKKKCAAgoooIACCiiggAIKKFAuYAC03MWpCiiggAIKKKCAAgoooIACCiiggAIKKNAAAQOgDdiJboICCiiggAIKKKCAAgoooIACCiiggAIKlAsYAC13caoCCiiggAIKKKCAAgoooIACCiiggAIKNEDAAGgDdqKboIACCiiggAIKKKCAAgoooIACCiiggALlAgZAy12cqoACCiiggAIKKKCAAgoooIACCiiggAINEDAA2oCd6CYooIACCiiggAIKKKCAAgoooIACCiigQLmAAdByF6cqoIACCiiggAIKKKCAAgoooIACCiigQAMEDIA2YCe6CQoooIACCiiggAIKKKCAAgoooIACCihQLmAAtNzFqQoooIACCiiggAIKKKCAAgoooIACCijQAAEDoA3YiW6CAgoooIACCiiggAIKKKCAAgoooIACCpQLGAAtd3GqAgoooIACCiiggAIKKKCAAgoooIACCjRAwABoA3aim6CAAgoooIACCiiggAIKKKCAAgoooIAC5QIGQMtdnKqAAgoooIACCiiggAIKKKCAAgoooIACDRAwANqAnegmKKCAAgoooIACCiiggAIKKKCAAgoooEC5gAHQchenKqCAAgoooIACCiiggAIKKKCAAgoooEADBAyANmAnugkKKKCAAgoooIACCiiggAIKKKCAAgooUC5gALTcxakKKKCAAgoooIACCiiggAIKKKCAAgoo0AABA6AN2IluggIKKKCAAgoooIACCiiggAIKKKCAAgqUCxgALXdxqgIKKKCAAgoooIACCiiggAIKKKCAAgo0QMAAaAN2opuggAIKKKCAAgoooIACCiiggAIKKKCAAuUCBkDLXZyqgAIKKKCAAgoooIACCiiggAIKKKCAAg0QMADagJ3oJiiggAIKKKCAAgoooIACCiiggAIKKKBAuYAB0HIXpyqggAIKKKCAAgoooIACCiiggAIKKKBAAwQMgDZgJ7oJCiiggAIKKKCAAgoooIACCiiggAIKKFAuYAC03MWpCiiggAIKKKCAAgoooIACCiiggAIKKNAAAQOgDdiJboICCiiggAIKKKCAAgoooIACCiiggAIKlAsYAC13caoCCiiggAIKKKCAAgoooIACCiiggAIKNEDAAGgDdqKboIACCiiggAIKKKCAAgoooIACCiiggALlAgZAy12cqoACCiiggAIKKKCAAgoooIACCiiggAINEDAA2oCd6CYooIACCiiggAIKKKCAAgoooIACCiigQLmAAdByF6cqoIACCiiggAIKKKCAAgoooIACCiigQAMEDIA2YCe6CQoooIACCiiggAIKKKCAAgoooIACCihQLmAAtNzFqQoooIACCiiggAIKKKCAAgoooIACCijQAAEDoA3YiW6CAgoooIACCiiggAIKKKCAAgoooIACCpQLGAAtd3GqAgoooIACCiiggAIKKKCAAgoooIACCjRAwABoA3aim6CAAgoooIACCiiggAIKKKCAAgoooIAC5QIGQMtdnKqAAgoooIACCiiggAIKKKCAAgoooIACDRAwANqAnegmKKCAAgoooIACCiiggAIKKKCAAgoooEC5gAHQchenKqCAAgoooIACCiiggAIKKKCAAgoooEADBAyANmAnugkKKKCAAgoooIACCiiggAIKKKCAAgooUC5gALTcxakKKKCAAgoooIACCiiggAIKKKCAAgoo0AABA6AN2IluggIKKKCAAgoooIACCiiggAIKKKCAAgqUCxgALXdxqgIKKKCAAgoooIACCiiggAIKKKCAAgo0QMAAaAN2opuggAIKKKCAAgoooIACCiiggAIKKKCAAuUCBkDLXZyqgAIKKKCAAgoooIACCiiggAIKKKCAAg0QMADagJ3oJiiggAIKKKCAAgoooIACCiiggAIKKKBAuYAB0HIXpyqggAIKKKCAAgoooIACCiiggAIKKKBAAwQMgDZgJ7oJCiiggAIKKKCAAgoooIACCiiggAIKKFAuYAC03MWpCiiggAIKKKCAAgoooIACCiiggAIKKNAAAQOgDdiJboICCiiggAIKKKCAAgoooIACCiiggAIKlAsYAC13caoCCiiggAIKKKCAAgoooIACCiiggAIKNEDAAGgDdqKboIACCiiggAIKKKCAAgoooIACCiiggALlAgZAy12cqoACCiiggAIKKKCAAgoooIACCiiggAINEDAA2oCd6CYooIACCiiggAIKKKCAAgoooIACCiigQLmAAdByF6cqoIACCiiggAIKKKCAAgoooIACCiigQAMEDIA2YCe6CQoooIACCiiggAIKKKCAAgoooIACCihQLmAAtNzFqQoooIACCiiggAIKKKCAAgoooIACCijQAAEDoA3YiW6CAgoooIACCiiggAIKKKCAAgoooIACCpQLGAAtd3GqAgoooIACCiiggAIKKKCAAgoooIACCjRAwABoA3aim6CAAgoooIACCiiggAIKKKCAAgoooIAC5QIGQMtdnKqAAgoooIACCiiggAIKKKCAAgoooIACDRAwANqAnegmKKCAAgoooIACCiiggAIKKKCAAgoooEC5gAHQchenKqCAAgoooIACCiiggAIKKKCAAgoooEADBAyANmAnugkKKKCAAgoooIACCiiggAIKKKCAAgooUC5gALTcxakKKKCAAgoooIACCiiggAIKKKCAAgoo0AABA6AN2IluggIKKKCAAgoooIACCiiggAIKKKCAAgqUCxgALXdxqgIKKKCAAgoooIACCiiggAIKKKCAAgo0QMAAaAN2opuggAIKKKCAAgoooIACCiiggAIKKKCAAuUCBkDLXZyqgAIKKKCAAgoooIACCiiggAIKKKCAAg0QMADagJ3oJiiggAIKKKCAAgoooIACCiiggAIKKKBAuYAB0HIXpyqggAIKKKCAAgoooIACCiiggAIKKKBAAwQMgDZgJ7oJCiiggAIKKKCAAgoooIACCiiggAIKKFAuYAC03MWpCiiggAIKKKCAAgoooIACCiiggAIKKNAAAQOgDdiJboICCiiggAIKKKCAAgoooIACCiiggAIKlAsYAC13caoCCiiggAIKKKCAAgoooIACCiiggAIKNEDAAGgDdqKboIACCiiggAIKKKCAAgoooIACCiiggALlAgZAy12cqoACCiiggAIKKKCAAgoooIACCiiggAINEDAA2oCd6CYooIACCiiggAIKKKCAAgoooIACCiigQLmAAdByF6cqoIACCiiggAIKKKCAAgoooIACCiigQAMEDIA2YCe6CQoooIACCiiggAIKKKCAAgoooIACCihQLmAAtNzFqQoooIACCiiggAIKKKCAAgoooIACCijQAAEDoA3YiW6CAgoooIACCiiggAIKKKCAAgoooIACCpQLGAAtd3GqAgoooIACCiiggAIKKKCAAgoooIACCjRAwABoA3aim6CAAgoooIACCiiggAIKKKCAAgoooIAC5QIGQMtdnKqAAgoooIACCiiggAIKKKCAAgoooIACDRAwANqAnegmKKCAAgoooIACCiiggAIKKKCAAgoooEC5gAHQchenKqCAAgoooIACCiiggAIKKKCAAgoooEADBAyANmAnugkKKKCAAgoooIACCiiggAIKKKCAAgooUC5gALTcxakKKKCAAgoooIACCiiggAIKKKCAAgoo0AABA6AN2IluggIKKKCAAgoooIACCiiggAIKKKCAAgqUCxgALXdxqgIKKKCAAgoooIACCiiggAIKKKCAAgo0QMAAaAN2opuggAIKKKCAAgoooIACCiiggAIKKKCAAuUCBkDLXZyqgAIKKKCAAgoooIACCiiggAIKKKCAAg0QMADagJ3oJiiggAIKKKCAAgoooIACCiiggAIKKKBAuYAB0HIXpyqggAIKKKCAAgoooIACCiiggAIKKKBAAwQMgDZgJ7oJCiiggAIKKKCAAgoooIACCiiggAIKKFAuYAC03MWpCiiggAIKKKCAAgoooIACCiiggAIKKNAAAQOgDdiJboICCiiggAIKKKCAAgoooIACCiiggAIKlAsYAC13caoCCiiggAIKKKCAAgoooIACCiiggAIKNEDAAGgDdqKboIACCiiggAIKKKCAAgoooIACCiiggALlAouUT3aqAgoooEATBebPnx/uuOOOtpu20EILheWXXz4ssog/EW2hpsiLv/zlL8MjjzwSVlxxxfCEJzxhimy1m5kLWG/kGj4fT4E777wz/PnPfw6PecxjwsyZM8dzUc67xgJ33XVXeOCBB9qu4eMe97iw9NJLt32PLyrQScBznE5Cvq5AswSm/XdBadYmuTUKKKCAAq0Efvvb34ZNN9201csj0xdbbLGwyiqrhNVXXz1svfXWYfbs2SOv+WS4Ag899FA4+uijw6KLLhre9a53dVz4v/71r3DJJZeEX//61+E///lPWG+99cIGG2wQg9odP1zyhpVXXjn8+9//DqeffnrYcsstS97hpKYLWG9Mvj38rW99K3z7298OW221Vdhoo406bsAg9cZ1110XrrzyynDrrbeGGTNmhA033DCsueaasc7quODCG0455ZTwvve9L8yaNStcfvnlhVf9c6oI7L333uFLX/pSx83lZu1qq60Wnv3sZ4e3ve1t3qTrKFbdGx5++OFw0003hWuvvTb+u+++++JNi2c961nhxS9+ccvv//XXXx9+//vfd1yRzTffPDz2sY8d875B6qoxM1swwXOcMhWnKdBcAdN7mrtv3TIFFFCgbwECZ9wV59+FF14YA29ckFRVvvvd74Z3v/vdcXZf+cpXSk9yq1rWZJ8PVqeeemp4/OMf3zEAOm/evLDvvvuGv/71ryOb/elPfzo+f9nLXhY+8YlPmNk7IuOTqgWsN6oW7X9+J554YvjZz34WnvGMZ3QMgPZbbzz44IOxvikLVBG4OOusszouu/8t9JMKhPCXv/wl/iMAT8D8nHPOCdOnT6+MZrfddgvcAHr9618f9tlnn8rmO9lnRBBy1113Dd/5zndKN4WA9MknnxyD08U3fPSjHw1f/vKXi5PH/H3VVVeFlVZaadT0fuuqUTPxDwUUmNICBkCn9O534xVQYCoLHHDAAeGNb3zjGAIaBvzxj38M3KXnIvruu++OGTlPecpTwmte85ox7+9nAk3buKig0LzaUi5A5iX7oJvy05/+NHCxxmeWXHLJsMkmm8RsjB//+McxEPLVr341zJkzJ3zkIx8JdHNgUaAfAeuNftSG+5mvfe1r8TvfzVIHqTe4KcayKLQYeOELXxj+/ve/x6AITdnf/OY3h8997nNh7bXX7mZVfI8CYwS48Udws6yQcfirX/0qXHbZZTFblFYP2223Xfje975X9va+pnEu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ANrYXeuGKaCAAgoooIACCiiggAIKKKCAAgoooMAiEiiggAIKKKCAAlULMMDR7rvv7qjJVcM6PwUUKBVg5Oj58+cHBmazKKCAAuMtYJ0z3sLOX4HqBRwEqXpT56iAAgoooIACCiiggAIKKKCAAgoooIACNRGwCXxNdoSroYACCiiggAIKKKCAAgoooIACCiiggALVCxgArd7UOSqggAIKKKCAAgoooIACCiiggAIKKKBATQQMgNZkR7gaCiiggAIKKKCAAgoooIACCiiggAIKKFC9gAHQ6k2dowIKKKCAAgoooIACCiiggAIKKKCAAgrURMAAaE12hKuhgAIKKKCAAgoooIACCiiggAIKKKCAAtULGACt3tQ5KqCAAgoooIACCiiggAIKKKCAAgoooEBNBAyA1mRHuBoKKKCAAgoooIACCiiggAIKKKCAAgooUL2AAdDqTZ2jAgoooIACCiiggAIKKKCAAgoooIACCtREwABoTXaEq6GAAgoooIACCiiggAIKKKCAAgoooIAC1QsYAK3e1DkqoIACCiiggAIKKKCAAgoooIACCiigQE0EDIDWZEe4GgoooIACCiiggAIKKKCAAgoooIACCihQvYAB0OpNnaMCCiiggAIKKKCAAgoooIACCiiggAIK1ETAAGhNdoSroYACCiiggAIKKKCAAgoooIACCiiggALVCxgArd7UOSqggAIKKKCAAgoooIACCiiggAIKKKBATQQMgNZkR7gaCiiggAIKKKCAAgoooIACCiiggAIKKFC9gAHQ6k2dowIKKKCAAgoooIACCiiggAIKKKCAAgrURMAAaE12hKuhgAIKKKCAAgoooIACCiiggAIKKKCAAtULGACt3tQ5KqCAAgoooIACCiiggAIKKKCAAgoooEBNBAyA1mTCkY0jAAAlQ0lEQVRHuBoKKKCAAgoooIACCiiggAIKKKCAAgooUL3AItXP0jkqoIACCtRVYP78+eGOO+5ou3oLLbRQWH755cMii/gT0RZqirz4y1/+MjzyyCNhxRVXDE94whOmyFa7mbmA9Uau4fPxFLjzzjvDn//85/CYxzwmzJw5czwX5bxrLHDXXXeFBx54oO0aPu5xjwtLL7102/f4ogKdBDzH6STk6wo0S2DafxeUZm2SW6OAAgoo0Ergt7/9bdh0001bvTwyfbHFFgurrLJKWH311cPWW28dZs+ePfKaT8ZX4Prrrw+///3vOy5k8803D4997GPHvO9f//pXuOSSS8Kvf/3r8J///Cest956YYMNNohB7TFv7mLCyiuvHP7973+H008/PWy55ZZdfMK3NE3AemNy7NG77747XHvtteHnP/95uOmmm8Jyyy0Xg4gbb7xxx2DiIPXGddddF6688spw6623hhkzZoQNN9wwrLnmmmHRRRftGe6UU04J73vf+8KsWbPC5Zdf3vPn/UAzBPbee+/wpS99qePGcLN2tdVWC89+9rPD2972Nm/SdRSr7g3333//qPpm2WWXDdOnT4/ni09/+tNbLshznJY0vqCAAkMQML1nCMguQgEFFJhsAgTOuCvOvwsvvDC8613vClyQVFW++93vhne/+91xdl/5yldKA3lVLWuyzeejH/1o+PKXv9xxta+66qqw0korjXrfvHnzwr777hv++te/jkz/9Kc/HZ+/7GUvC5/4xCfM7B2R8UnVAtYbVYt2P78rrrgi7LHHHuHBBx8c8yGy+akXCBCVZfb3W2+wLOZbFqji5sxZZ50VNtpoozHr4wQFqhL4y1/+EvhHAJ6A+TnnnBODcFXNf7fddgvcAHr9618f9tlnn6pmO+nnQxBz++23D3//+9/HbMuRRx4ZX3vve98buJleLJ7jFEX8WwEFhilgAHSY2i5LAQUUqJHAAQccEN74xjeOWSMaBvzxj38MnOCeeOKJgawiMnKe8pSnhNe85jVj3t/PBJq2cVFBoXm15VGBlP1JAKEsWJHeSVcFefnpT38auFgjW3PJJZcMm2yyScz6+vGPfxx+9rOfha9+9athzpw54SMf+Ugofjafj88VaCdgvdFOZ2Je47v91re+NTz00ENhmWWWiRmYa6yxRuzuhBtMNCc+4YQTwn333Tdy4ymt6SD1BjfFvva1r8VZ0WLghS98YQyIfOc73wk0ZX/zm98cPve5z4W11147Lc5HBXoSePzjHx+Dm2Uf4nj+1a9+FS677LIYhKfVw3bbbRe+973vlb29r2mcC3Gu8re//a2vzzfxQ2R8E/z8xz/+EeiGgBYmZOFyw5wbs9RD5557bswAP/roo8cQeI4zhsQJCigwRAEDoEPEdlEKKKBAnQS4sKD5WFkh2EnT6ec///mxORMntGRYVBUALVum0/4n8Ic//CE+IaOrXTOyohdZugQ/2a9kkBKQ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" width="672" /></p>
</div>
<div id="conclusion" class="section level2 unnumbered">
<h2>Conclusion</h2>
<p>It is clear from these figures that compounding nature of fees have a dramatic impact on overall cumulative wealth over time. Investors should be keenly aware of this fact and take it into consideration when designing their their long term strategies.</p>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
